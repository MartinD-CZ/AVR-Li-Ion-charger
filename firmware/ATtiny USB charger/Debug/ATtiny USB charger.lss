
ATtiny USB charger.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f40  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000fb4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002f  00800060  00800060  00000fb4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000fb4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000fe4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  00001020  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002138  00000000  00000000  000011c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ba4  00000000  00000000  00003300  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000010e5  00000000  00000000  00003ea4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000278  00000000  00000000  00004f8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007aa  00000000  00000000  00005204  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000119a  00000000  00000000  000059ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000130  00000000  00000000  00006b48  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	ac c1       	rjmp	.+856    	; 0x35a <__ctors_end>
   2:	c4 c1       	rjmp	.+904    	; 0x38c <__bad_interrupt>
   4:	9e c6       	rjmp	.+3388   	; 0xd42 <__vector_2>
   6:	c2 c1       	rjmp	.+900    	; 0x38c <__bad_interrupt>
   8:	c1 c1       	rjmp	.+898    	; 0x38c <__bad_interrupt>
   a:	c0 c1       	rjmp	.+896    	; 0x38c <__bad_interrupt>
   c:	d9 c5       	rjmp	.+2994   	; 0xbc0 <__vector_6>
   e:	be c1       	rjmp	.+892    	; 0x38c <__bad_interrupt>
  10:	bd c1       	rjmp	.+890    	; 0x38c <__bad_interrupt>
  12:	bc c1       	rjmp	.+888    	; 0x38c <__bad_interrupt>
  14:	bb c1       	rjmp	.+886    	; 0x38c <__bad_interrupt>
  16:	ba c1       	rjmp	.+884    	; 0x38c <__bad_interrupt>
  18:	b9 c1       	rjmp	.+882    	; 0x38c <__bad_interrupt>
  1a:	b8 c1       	rjmp	.+880    	; 0x38c <__bad_interrupt>
  1c:	b7 c1       	rjmp	.+878    	; 0x38c <__bad_interrupt>
  1e:	b6 c1       	rjmp	.+876    	; 0x38c <__bad_interrupt>
  20:	b5 c1       	rjmp	.+874    	; 0x38c <__bad_interrupt>

00000022 <__trampolines_end>:
  22:	56 61       	ori	r21, 0x16	; 22
  24:	6c 75       	andi	r22, 0x5C	; 92
  26:	65 20       	and	r6, r5
  28:	63 6c       	ori	r22, 0xC3	; 195
  2a:	69 70       	andi	r22, 0x09	; 9
  2c:	70 65       	ori	r23, 0x50	; 80
  2e:	64 20       	and	r6, r4
  30:	2d 20       	and	r2, r13
	...

00000033 <_ZZ9printDatavE3__c_3>:
  33:	0a 74 6f 20 70 72 69 6e 74 20 74 68 65 20 74 61     .to print the ta
  43:	62 6c 65 20 61 67 61 69 6e 2c 20 73 65 6e 64 20     ble again, send 
  53:	44 41 54 41 3b 20 74 6f 20 73 61 76 65 20 26 20     DATA; to save & 
  63:	65 78 69 74 2c 20 73 65 6e 64 20 45 58 49 54 0a     exit, send EXIT.
	...

00000074 <_ZZ9printDatavE3__c_2>:
  74:	70 61 72 61 6d 4e 61 6d 65 20 20 20 75 6e 69 74     paramName   unit
  84:	20 20 20 20 76 61 6c 75 65 20 20 20 6d 69 6e 20         value   min 
  94:	20 20 20 20 6d 61 78 20 20 20 20 20 64 65 66 61         max     defa
  a4:	75 6c 74 0a 00                                      ult..

000000a9 <_ZZ9printDatavE3__c_1>:
  a9:	74 6f 20 63 68 61 6e 67 65 20 70 61 72 61 6d 65     to change parame
  b9:	74 65 72 73 2c 20 73 65 6e 64 3a 20 70 61 72 61     ters, send: para
  c9:	6d 4e 61 6d 65 3d 56 61 6c 75 65 20 20 20 66 6f     mName=Value   fo
  d9:	72 20 65 78 61 6d 70 6c 65 3a 20 56 6d 61 78 3d     r example: Vmax=
  e9:	34 35 30 30 0a 64 6f 20 6e 6f 74 20 66 6f 72 67     4500.do not forg
  f9:	65 74 20 74 6f 20 73 65 6e 64 20 74 68 65 20 4e     et to send the N
 109:	65 77 4c 69 6e 65 20 28 61 6b 61 20 4c 69 6e 65     ewLine (aka Line
 119:	46 65 65 64 29 20 63 68 61 72 61 63 74 65 72 20     Feed) character 
 129:	61 74 20 74 68 65 20 65 6e 64 0a 0a 00              at the end...

00000136 <_ZZ9printDatavE3__c_0>:
 136:	72 65 76 2e 20 31 2e 30 43 20 20 20 20 20 65 6d     rev. 1.0C     em
 146:	62 65 64 62 6c 6f 67 2e 65 75 0a 0a 00              bedblog.eu...

00000153 <_ZZ9printDatavE3__c>:
 153:	0a 0a 0a 3d 3d 3d 20 41 56 52 20 4c 69 2d 49 6f     ...=== AVR Li-Io
 163:	6e 20 43 68 61 72 67 65 72 20 3d 3d 3d 0a 00        n Charger ===..

00000172 <_ZZ12configPortalvE3__c_1>:
 172:	20 73 65 74 20 74 6f 20 00                           set to .

0000017b <_ZZ12configPortalvE3__c_0>:
 17b:	49 6e 76 61 6c 69 64 20 63 6f 6d 6d 61 6e 64 21     Invalid command!
 18b:	0a 00                                               ..

0000018d <_ZZ12configPortalvE3__c>:
 18d:	64 61 74 61 20 73 61 76 65 64 2c 20 72 65 73 74     data saved, rest
 19d:	61 72 74 69 6e 67 0a 00                             arting..

000001a5 <_ZL4unit>:
 1a5:	6d 56 6d 56 6d 41 6d 41 6d 41 6d 56 43 20 43 20     mVmVmAmAmAmVC C 
	...

000001b6 <_ZL9paramName>:
 1b6:	56 6d 61 78 56 70 72 65 49 6d 61 78 49 63 75 74     VmaxVpreImaxIcut
 1c6:	49 70 72 65 56 63 6f 6e 54 6d 69 6e 54 6d 61 78     IpreVconTminTmax
	...

000001d7 <_ZL9maxValues>:
 1d7:	94 11 94 11 d0 07 d0 07 d0 07 a0 0f 32 00 7d 00     ............2.}.

000001e7 <_ZL9minValues>:
 1e7:	f4 01 f4 01 64 00 0a 00 0a 00 64 00 00 00 00 00     ....d.....d.....

000001f7 <_ZL13defaultValues>:
 1f7:	68 10 b8 0b e8 03 64 00 c8 00 bc 02 00 00 37 00     h.....d.......7.

00000207 <_ZZ4mainE3__c_13>:
 207:	54 45 4d 50 45 52 41 54 55 52 45 20 45 52 52 4f     TEMPERATURE ERRO
 217:	52 0a 00                                            R..

0000021a <_ZZ4mainE3__c_12>:
 21a:	3d 3d 46 49 4e 49 53 48 45 44 3d 3d 0a 00           ==FINISHED==..

00000228 <_ZZ4mainE3__c_11>:
 228:	0a 00                                               ..

0000022a <_ZZ4mainE3__c_10>:
 22a:	20 43 00                                             C.

0000022d <_ZZ4mainE3__c_9>:
 22d:	3b 20 74 3a 20 00                                   ; t: .

00000233 <_ZZ4mainE3__c_8>:
 233:	20 6d 41 00                                          mA.

00000237 <_ZZ4mainE3__c_7>:
 237:	20 6d 56 3b 20 49 6f 75 74 3a 20 00                  mV; Iout: .

00000243 <_ZZ4mainE3__c_6>:
 243:	56 6f 75 74 3a 20 00                                Vout: .

0000024a <_ZZ4mainE3__c_5>:
 24a:	74 6f 20 73 74 61 72 74 20 63 6f 6e 66 69 67 2c     to start config,
 25a:	20 73 65 6e 64 20 61 6e 79 74 68 69 6e 67 20 76      send anything v
 26a:	69 61 20 73 65 72 69 61 6c 20 74 6f 20 74 68 65     ia serial to the
 27a:	20 64 65 76 69 63 65 3b 20 61 6c 74 65 72 6e 61      device; alterna
 28a:	74 69 76 65 6c 79 2c 20 63 6f 6e 6e 65 63 74 20     tively, connect 
 29a:	61 20 62 61 74 74 65 72 79 20 74 6f 20 73 74 61     a battery to sta
 2aa:	72 74 20 63 68 61 72 67 69 6e 67 0a 00              rt charging..

000002b7 <_ZZ4mainE3__c_4>:
 2b7:	77 61 69 74 69 6e 67 20 66 6f 72 20 62 61 74 74     waiting for batt
 2c7:	65 72 79 20 63 6f 6e 6e 65 63 74 69 6f 6e 2e 2e     ery connection..
 2d7:	2e 0a 00                                            ...

000002da <_ZZ4mainE3__c_3>:
 2da:	54 65 6d 70 65 72 61 74 75 72 65 20 73 65 6e 73     Temperature sens
 2ea:	6f 72 20 6e 6f 74 20 66 6f 75 6e 64 0a 00           or not found..

000002f8 <_ZZ4mainE3__c_2>:
 2f8:	54 65 6d 70 65 72 61 74 75 72 65 20 73 65 6e 73     Temperature sens
 308:	6f 72 20 64 65 74 65 63 74 65 64 0a 00              or detected..

00000315 <_ZZ4mainE3__c_1>:
 315:	4e 6f 74 68 69 6e 67 20 69 6e 20 45 45 50 52 4f     Nothing in EEPRO
 325:	4d 2c 20 64 65 66 61 75 6c 74 73 20 75 73 65 64     M, defaults used
 335:	0a 00                                               ..

00000337 <_ZZ4mainE3__c_0>:
 337:	44 61 74 61 20 6c 6f 61 64 65 64 20 66 72 6f 6d     Data loaded from
 347:	20 45 45 50 52 4f 4d 0a 00                           EEPROM..

00000350 <_ZZ4mainE3__c>:
 350:	0a 0a 0a 53 54 41 52 54 0a 00                       ...START..

0000035a <__ctors_end>:
 35a:	11 24       	eor	r1, r1
 35c:	1f be       	out	0x3f, r1	; 63
 35e:	cf e5       	ldi	r28, 0x5F	; 95
 360:	d1 e0       	ldi	r29, 0x01	; 1
 362:	de bf       	out	0x3e, r29	; 62
 364:	cd bf       	out	0x3d, r28	; 61

00000366 <_Z8wdt_initv>:
	}
}

void wdt_init(void)
{
	MCUSR = 0;
 366:	14 be       	out	0x34, r1	; 52
				"out __SREG__,__tmp_reg__"   "\n\t"
				: [TEMPREG] "=d" (temp_reg)
				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
				: "r0"
		);
 368:	0f b6       	in	r0, 0x3f	; 63
 36a:	f8 94       	cli
 36c:	a8 95       	wdr
 36e:	81 b5       	in	r24, 0x21	; 33
 370:	88 61       	ori	r24, 0x18	; 24
 372:	81 bd       	out	0x21, r24	; 33
 374:	11 bc       	out	0x21, r1	; 33
 376:	0f be       	out	0x3f, r0	; 63

00000378 <__do_clear_bss>:
 378:	20 e0       	ldi	r18, 0x00	; 0
 37a:	a0 e6       	ldi	r26, 0x60	; 96
 37c:	b0 e0       	ldi	r27, 0x00	; 0
 37e:	01 c0       	rjmp	.+2      	; 0x382 <.do_clear_bss_start>

00000380 <.do_clear_bss_loop>:
 380:	1d 92       	st	X+, r1

00000382 <.do_clear_bss_start>:
 382:	af 38       	cpi	r26, 0x8F	; 143
 384:	b2 07       	cpc	r27, r18
 386:	e1 f7       	brne	.-8      	; 0x380 <.do_clear_bss_loop>
 388:	2a d2       	rcall	.+1108   	; 0x7de <main>
 38a:	d8 c5       	rjmp	.+2992   	; 0xf3c <_exit>

0000038c <__bad_interrupt>:
 38c:	39 ce       	rjmp	.-910    	; 0x0 <__vectors>

0000038e <_Z15adc_measurementhh>:
#include "..\defines.h"

//return the value of a given channel in milivolts (with a 4.096 V reference at PA0)
uint16_t adc_measurement(uint8_t channel, uint8_t samples)
{
	switch (channel)
 38e:	81 30       	cpi	r24, 0x01	; 1
 390:	39 f0       	breq	.+14     	; 0x3a0 <_Z15adc_measurementhh+0x12>
 392:	20 f0       	brcs	.+8      	; 0x39c <_Z15adc_measurementhh+0xe>
 394:	82 30       	cpi	r24, 0x02	; 2
 396:	31 f4       	brne	.+12     	; 0x3a4 <_Z15adc_measurementhh+0x16>
			break;
		case ADC_IOUT:
			ADMUX = (1 << REFS0) | (1 << MUX0) | (1 << MUX2) | (1 << MUX3);
			break;
		case ADC_TEMP:
			ADMUX = (1 << REFS0) | (1 << MUX2);
 398:	84 e4       	ldi	r24, 0x44	; 68
 39a:	03 c0       	rjmp	.+6      	; 0x3a2 <_Z15adc_measurementhh+0x14>
uint16_t adc_measurement(uint8_t channel, uint8_t samples)
{
	switch (channel)
	{
		case ADC_VOUT:
			ADMUX = (1 << REFS0) | (1 << MUX0) | (1 << MUX1);
 39c:	83 e4       	ldi	r24, 0x43	; 67
 39e:	01 c0       	rjmp	.+2      	; 0x3a2 <_Z15adc_measurementhh+0x14>
			break;
		case ADC_IOUT:
			ADMUX = (1 << REFS0) | (1 << MUX0) | (1 << MUX2) | (1 << MUX3);
 3a0:	8d e4       	ldi	r24, 0x4D	; 77
			break;
		case ADC_TEMP:
			ADMUX = (1 << REFS0) | (1 << MUX2);
 3a2:	87 b9       	out	0x07, r24	; 7
			break;
	}

	ADCSRA = (1 << ADEN) | (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
 3a4:	87 e8       	ldi	r24, 0x87	; 135
 3a6:	86 b9       	out	0x06, r24	; 6

	//start first conversion
	ADCSRA |= (1 << ADSC);
 3a8:	36 9a       	sbi	0x06, 6	; 6
	while (ADCSRA & (1 << ADSC));
 3aa:	36 99       	sbic	0x06, 6	; 6
 3ac:	fe cf       	rjmp	.-4      	; 0x3aa <_Z15adc_measurementhh+0x1c>
 3ae:	90 e0       	ldi	r25, 0x00	; 0
 3b0:	20 e0       	ldi	r18, 0x00	; 0
 3b2:	30 e0       	ldi	r19, 0x00	; 0

	uint16_t data = 0;
	for (uint8_t i = 0; i < samples; i ++)
 3b4:	96 17       	cp	r25, r22
 3b6:	49 f0       	breq	.+18     	; 0x3ca <_Z15adc_measurementhh+0x3c>
	{
		ADCSRA |= (1 << ADSC);
 3b8:	36 9a       	sbi	0x06, 6	; 6
		while (ADCSRA & (1 << ADSC));
 3ba:	36 99       	sbic	0x06, 6	; 6
 3bc:	fe cf       	rjmp	.-4      	; 0x3ba <_Z15adc_measurementhh+0x2c>
		data += ADC;
 3be:	44 b1       	in	r20, 0x04	; 4
 3c0:	55 b1       	in	r21, 0x05	; 5
 3c2:	24 0f       	add	r18, r20
 3c4:	35 1f       	adc	r19, r21
	//start first conversion
	ADCSRA |= (1 << ADSC);
	while (ADCSRA & (1 << ADSC));

	uint16_t data = 0;
	for (uint8_t i = 0; i < samples; i ++)
 3c6:	9f 5f       	subi	r25, 0xFF	; 255
 3c8:	f5 cf       	rjmp	.-22     	; 0x3b4 <_Z15adc_measurementhh+0x26>
		ADCSRA |= (1 << ADSC);
		while (ADCSRA & (1 << ADSC));
		data += ADC;
	}

	return ((data * 4) / samples);
 3ca:	22 0f       	add	r18, r18
 3cc:	33 1f       	adc	r19, r19
 3ce:	22 0f       	add	r18, r18
 3d0:	33 1f       	adc	r19, r19
 3d2:	69 2f       	mov	r22, r25
 3d4:	70 e0       	ldi	r23, 0x00	; 0
 3d6:	c9 01       	movw	r24, r18
 3d8:	05 d5       	rcall	.+2570   	; 0xde4 <__udivmodhi4>
 3da:	cb 01       	movw	r24, r22
 3dc:	08 95       	ret

000003de <_Z10readEEPROMv>:
const char PROGMEM paramName[] = "VmaxVpreImaxIcutIpreVconTminTmax";
const char PROGMEM unit[] = "mVmVmAmAmAmVC C ";
uint16_t actValue[8];

bool readEEPROM(void)
{
 3de:	0f 93       	push	r16
 3e0:	1f 93       	push	r17
 3e2:	cf 93       	push	r28
 3e4:	df 93       	push	r29
	if (eeprom_read_byte(0) == EEPROM_FLAG)
 3e6:	80 e0       	ldi	r24, 0x00	; 0
 3e8:	90 e0       	ldi	r25, 0x00	; 0
 3ea:	7c d5       	rcall	.+2808   	; 0xee4 <eeprom_read_byte>
 3ec:	81 3a       	cpi	r24, 0xA1	; 161
 3ee:	79 f4       	brne	.+30     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
 3f0:	01 e7       	ldi	r16, 0x71	; 113
 3f2:	10 e0       	ldi	r17, 0x00	; 0
 3f4:	c1 e0       	ldi	r28, 0x01	; 1
 3f6:	d0 e0       	ldi	r29, 0x00	; 0
	{
		//we have a valid data
		for (uint8_t i = 0; i < 8; i++)
			param[i] = eeprom_read_word((const uint16_t*)(i * 2 + 1));
 3f8:	ce 01       	movw	r24, r28
 3fa:	7c d5       	rcall	.+2808   	; 0xef4 <eeprom_read_word>
 3fc:	f8 01       	movw	r30, r16
 3fe:	81 93       	st	Z+, r24
 400:	91 93       	st	Z+, r25
 402:	8f 01       	movw	r16, r30
 404:	22 96       	adiw	r28, 0x02	; 2
bool readEEPROM(void)
{
	if (eeprom_read_byte(0) == EEPROM_FLAG)
	{
		//we have a valid data
		for (uint8_t i = 0; i < 8; i++)
 406:	c1 31       	cpi	r28, 0x11	; 17
 408:	d1 05       	cpc	r29, r1
 40a:	b1 f7       	brne	.-20     	; 0x3f8 <_Z10readEEPROMv+0x1a>
 40c:	11 c0       	rjmp	.+34     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
 40e:	87 ef       	ldi	r24, 0xF7	; 247
 410:	91 e0       	ldi	r25, 0x01	; 1
 412:	a1 e7       	ldi	r26, 0x71	; 113
 414:	b0 e0       	ldi	r27, 0x00	; 0
 416:	21 e8       	ldi	r18, 0x81	; 129
 418:	30 e0       	ldi	r19, 0x00	; 0
		return true;
	}
	else
	{
		for (uint8_t i = 0; i < 8; i++)
			param[i] = pgm_read_word(&defaultValues[i]);
 41a:	fc 01       	movw	r30, r24
 41c:	45 91       	lpm	r20, Z+
 41e:	54 91       	lpm	r21, Z
 420:	4d 93       	st	X+, r20
 422:	5d 93       	st	X+, r21
 424:	02 96       	adiw	r24, 0x02	; 2

		return true;
	}
	else
	{
		for (uint8_t i = 0; i < 8; i++)
 426:	2a 17       	cp	r18, r26
 428:	3b 07       	cpc	r19, r27
 42a:	b9 f7       	brne	.-18     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
			param[i] = pgm_read_word(&defaultValues[i]);

		return false;
 42c:	80 e0       	ldi	r24, 0x00	; 0
 42e:	01 c0       	rjmp	.+2      	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
	{
		//we have a valid data
		for (uint8_t i = 0; i < 8; i++)
			param[i] = eeprom_read_word((const uint16_t*)(i * 2 + 1));

		return true;
 430:	81 e0       	ldi	r24, 0x01	; 1
		for (uint8_t i = 0; i < 8; i++)
			param[i] = pgm_read_word(&defaultValues[i]);

		return false;
	}
}
 432:	df 91       	pop	r29
 434:	cf 91       	pop	r28
 436:	1f 91       	pop	r17
 438:	0f 91       	pop	r16
 43a:	08 95       	ret

0000043c <_Z9printDatav>:
		}
	}
}

void printData(void)
{
 43c:	cf 92       	push	r12
 43e:	df 92       	push	r13
 440:	ef 92       	push	r14
 442:	ff 92       	push	r15
 444:	0f 93       	push	r16
 446:	1f 93       	push	r17
 448:	cf 93       	push	r28
 44a:	df 93       	push	r29
	dataReady = false;
 44c:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <dataReady>
	uart_sendString_P(PSTR("\n\n\n=== AVR Li-Ion Charger ===\n"));
 450:	83 e5       	ldi	r24, 0x53	; 83
 452:	91 e0       	ldi	r25, 0x01	; 1
 454:	24 d4       	rcall	.+2120   	; 0xc9e <_Z17uart_sendString_PPKc>
	uart_sendString_P(PSTR("rev. 1.0C     embedblog.eu\n\n"));
 456:	86 e3       	ldi	r24, 0x36	; 54
 458:	91 e0       	ldi	r25, 0x01	; 1
 45a:	21 d4       	rcall	.+2114   	; 0xc9e <_Z17uart_sendString_PPKc>
	uart_sendString_P(PSTR("to change parameters, send: paramName=Value   for example: Vmax=4500\ndo not forget to send the NewLine (aka LineFeed) character at the end\n\n"));
 45c:	89 ea       	ldi	r24, 0xA9	; 169
 45e:	90 e0       	ldi	r25, 0x00	; 0
 460:	1e d4       	rcall	.+2108   	; 0xc9e <_Z17uart_sendString_PPKc>
	uart_sendString_P(PSTR("paramName   unit    value   min     max     default\n"));
 462:	84 e7       	ldi	r24, 0x74	; 116
 464:	90 e0       	ldi	r25, 0x00	; 0
 466:	1b d4       	rcall	.+2102   	; 0xc9e <_Z17uart_sendString_PPKc>
 468:	91 e7       	ldi	r25, 0x71	; 113
 46a:	e9 2e       	mov	r14, r25
 46c:	90 e0       	ldi	r25, 0x00	; 0
 46e:	f9 2e       	mov	r15, r25
 470:	c0 e0       	ldi	r28, 0x00	; 0
 472:	d0 e0       	ldi	r29, 0x00	; 0
 474:	6e 01       	movw	r12, r28
 476:	cc 0c       	add	r12, r12
 478:	dd 1c       	adc	r13, r13
 47a:	00 e0       	ldi	r16, 0x00	; 0
 47c:	10 e0       	ldi	r17, 0x00	; 0

	uint8_t numLength;
	for (uint8_t i = 0; i < 8; i ++)
	{
		for (uint8_t j = 0; j < 4; j++)
			uart_sendChar(pgm_read_byte(&paramName[i * 4 + j]));
 47e:	f6 01       	movw	r30, r12
 480:	e0 0f       	add	r30, r16
 482:	f1 1f       	adc	r31, r17
 484:	ea 54       	subi	r30, 0x4A	; 74
 486:	fe 4f       	sbci	r31, 0xFE	; 254
 488:	84 91       	lpm	r24, Z
 48a:	d2 d3       	rcall	.+1956   	; 0xc30 <_Z13uart_sendCharc>
 48c:	0f 5f       	subi	r16, 0xFF	; 255
 48e:	1f 4f       	sbci	r17, 0xFF	; 255
	//characters:			12			6	    8	    8       8

	uint8_t numLength;
	for (uint8_t i = 0; i < 8; i ++)
	{
		for (uint8_t j = 0; j < 4; j++)
 490:	04 30       	cpi	r16, 0x04	; 4
 492:	11 05       	cpc	r17, r1
 494:	a1 f7       	brne	.-24     	; 0x47e <_Z9printDatav+0x42>
			uart_sendChar(pgm_read_byte(&paramName[i * 4 + j]));
		uart_sendCharRepeat(' ', 8);
 496:	68 e0       	ldi	r22, 0x08	; 8
 498:	80 e2       	ldi	r24, 0x20	; 32
 49a:	43 d4       	rcall	.+2182   	; 0xd22 <_Z19uart_sendCharRepeatch>

		uart_sendChar(pgm_read_byte(&unit[i * 2]));
 49c:	fe 01       	movw	r30, r28
 49e:	eb 55       	subi	r30, 0x5B	; 91
 4a0:	fe 4f       	sbci	r31, 0xFE	; 254
 4a2:	84 91       	lpm	r24, Z
 4a4:	c5 d3       	rcall	.+1930   	; 0xc30 <_Z13uart_sendCharc>
		uart_sendChar(pgm_read_byte(&unit[i * 2 + 1]));
 4a6:	fe 01       	movw	r30, r28
 4a8:	ea 55       	subi	r30, 0x5A	; 90
 4aa:	fe 4f       	sbci	r31, 0xFE	; 254
 4ac:	84 91       	lpm	r24, Z
 4ae:	c0 d3       	rcall	.+1920   	; 0xc30 <_Z13uart_sendCharc>
		uart_sendCharRepeat(' ', 6);
 4b0:	66 e0       	ldi	r22, 0x06	; 6
 4b2:	80 e2       	ldi	r24, 0x20	; 32
 4b4:	36 d4       	rcall	.+2156   	; 0xd22 <_Z19uart_sendCharRepeatch>

		numLength = uart_sendNumber(param[i]);
 4b6:	6a e0       	ldi	r22, 0x0A	; 10
 4b8:	f7 01       	movw	r30, r14
 4ba:	81 91       	ld	r24, Z+
 4bc:	91 91       	ld	r25, Z+
 4be:	7f 01       	movw	r14, r30
 4c0:	fc d3       	rcall	.+2040   	; 0xcba <_Z15uart_sendNumberjh>
		uart_sendCharRepeat(' ', 8 - numLength);
 4c2:	18 e0       	ldi	r17, 0x08	; 8
 4c4:	61 2f       	mov	r22, r17
 4c6:	68 1b       	sub	r22, r24
 4c8:	80 e2       	ldi	r24, 0x20	; 32
 4ca:	2b d4       	rcall	.+2134   	; 0xd22 <_Z19uart_sendCharRepeatch>

		numLength = uart_sendNumber(pgm_read_word(&minValues[i]));
 4cc:	fe 01       	movw	r30, r28
 4ce:	e9 51       	subi	r30, 0x19	; 25
 4d0:	fe 4f       	sbci	r31, 0xFE	; 254
 4d2:	85 91       	lpm	r24, Z+
 4d4:	94 91       	lpm	r25, Z
 4d6:	6a e0       	ldi	r22, 0x0A	; 10
 4d8:	f0 d3       	rcall	.+2016   	; 0xcba <_Z15uart_sendNumberjh>
		uart_sendCharRepeat(' ', 8 - numLength);
 4da:	61 2f       	mov	r22, r17
 4dc:	68 1b       	sub	r22, r24
 4de:	80 e2       	ldi	r24, 0x20	; 32
 4e0:	20 d4       	rcall	.+2112   	; 0xd22 <_Z19uart_sendCharRepeatch>

		numLength = uart_sendNumber(pgm_read_word(&maxValues[i]));
 4e2:	fe 01       	movw	r30, r28
 4e4:	e9 52       	subi	r30, 0x29	; 41
 4e6:	fe 4f       	sbci	r31, 0xFE	; 254
 4e8:	85 91       	lpm	r24, Z+
 4ea:	94 91       	lpm	r25, Z
 4ec:	6a e0       	ldi	r22, 0x0A	; 10
 4ee:	e5 d3       	rcall	.+1994   	; 0xcba <_Z15uart_sendNumberjh>
		uart_sendCharRepeat(' ', 8 - numLength);
 4f0:	61 2f       	mov	r22, r17
 4f2:	68 1b       	sub	r22, r24
 4f4:	80 e2       	ldi	r24, 0x20	; 32
 4f6:	15 d4       	rcall	.+2090   	; 0xd22 <_Z19uart_sendCharRepeatch>

		uart_sendNumber(pgm_read_word(&defaultValues[i]));
 4f8:	fe 01       	movw	r30, r28
 4fa:	e9 50       	subi	r30, 0x09	; 9
 4fc:	fe 4f       	sbci	r31, 0xFE	; 254
 4fe:	85 91       	lpm	r24, Z+
 500:	94 91       	lpm	r25, Z
 502:	6a e0       	ldi	r22, 0x0A	; 10
 504:	da d3       	rcall	.+1972   	; 0xcba <_Z15uart_sendNumberjh>
		uart_sendChar('\n');
 506:	8a e0       	ldi	r24, 0x0A	; 10
 508:	93 d3       	rcall	.+1830   	; 0xc30 <_Z13uart_sendCharc>
 50a:	22 96       	adiw	r28, 0x02	; 2
	uart_sendString_P(PSTR("to change parameters, send: paramName=Value   for example: Vmax=4500\ndo not forget to send the NewLine (aka LineFeed) character at the end\n\n"));
	uart_sendString_P(PSTR("paramName   unit    value   min     max     default\n"));
	//characters:			12			6	    8	    8       8

	uint8_t numLength;
	for (uint8_t i = 0; i < 8; i ++)
 50c:	c0 31       	cpi	r28, 0x10	; 16
 50e:	d1 05       	cpc	r29, r1
 510:	09 f0       	breq	.+2      	; 0x514 <_Z9printDatav+0xd8>
 512:	b0 cf       	rjmp	.-160    	; 0x474 <_Z9printDatav+0x38>

		uart_sendNumber(pgm_read_word(&defaultValues[i]));
		uart_sendChar('\n');
	}

	uart_sendString_P(PSTR("\nto print the table again, send DATA; to save & exit, send EXIT\n"));
 514:	83 e3       	ldi	r24, 0x33	; 51
 516:	90 e0       	ldi	r25, 0x00	; 0
}
 518:	df 91       	pop	r29
 51a:	cf 91       	pop	r28
 51c:	1f 91       	pop	r17
 51e:	0f 91       	pop	r16
 520:	ff 90       	pop	r15
 522:	ef 90       	pop	r14
 524:	df 90       	pop	r13
 526:	cf 90       	pop	r12

		uart_sendNumber(pgm_read_word(&defaultValues[i]));
		uart_sendChar('\n');
	}

	uart_sendString_P(PSTR("\nto print the table again, send DATA; to save & exit, send EXIT\n"));
 528:	ba c3       	rjmp	.+1908   	; 0xc9e <_Z17uart_sendString_PPKc>

0000052a <_Z10convertIntv>:
}

uint16_t convertInt()
{
 52a:	cf 93       	push	r28
 52c:	df 93       	push	r29
 52e:	00 d0       	rcall	.+0      	; 0x530 <_Z10convertIntv+0x6>
 530:	00 d0       	rcall	.+0      	; 0x532 <_Z10convertIntv+0x8>
 532:	cd b7       	in	r28, 0x3d	; 61
 534:	de b7       	in	r29, 0x3e	; 62
	char number[4];

	for (uint8_t i = 0; i < 4; i ++)
		number[i] = inputBuffer[5 + i];
 536:	e3 e8       	ldi	r30, 0x83	; 131
 538:	f0 e0       	ldi	r31, 0x00	; 0
 53a:	85 81       	ldd	r24, Z+5	; 0x05
 53c:	89 83       	std	Y+1, r24	; 0x01
 53e:	86 81       	ldd	r24, Z+6	; 0x06
 540:	8a 83       	std	Y+2, r24	; 0x02
 542:	87 81       	ldd	r24, Z+7	; 0x07
 544:	8b 83       	std	Y+3, r24	; 0x03
 546:	80 85       	ldd	r24, Z+8	; 0x08
 548:	8c 83       	std	Y+4, r24	; 0x04

	uint16_t result = atoi(number);
 54a:	ce 01       	movw	r24, r28
 54c:	01 96       	adiw	r24, 0x01	; 1
 54e:	5e d4       	rcall	.+2236   	; 0xe0c <atoi>
	return result;
}
 550:	0f 90       	pop	r0
 552:	0f 90       	pop	r0
 554:	0f 90       	pop	r0
 556:	0f 90       	pop	r0
 558:	df 91       	pop	r29
 55a:	cf 91       	pop	r28
 55c:	08 95       	ret

0000055e <_Z10saveEEPROMv>:

void saveEEPROM()
{
 55e:	0f 93       	push	r16
 560:	1f 93       	push	r17
 562:	cf 93       	push	r28
 564:	df 93       	push	r29
	eeprom_write_byte((uint8_t*)0, EEPROM_FLAG);
 566:	61 ea       	ldi	r22, 0xA1	; 161
 568:	80 e0       	ldi	r24, 0x00	; 0
 56a:	90 e0       	ldi	r25, 0x00	; 0
 56c:	c7 d4       	rcall	.+2446   	; 0xefc <eeprom_write_byte>
 56e:	01 e7       	ldi	r16, 0x71	; 113
 570:	10 e0       	ldi	r17, 0x00	; 0
 572:	c1 e0       	ldi	r28, 0x01	; 1
 574:	d0 e0       	ldi	r29, 0x00	; 0
	for (uint8_t i = 0; i < 8; i++)
	{
		eeprom_busy_wait();
 576:	e1 99       	sbic	0x1c, 1	; 28
 578:	fe cf       	rjmp	.-4      	; 0x576 <_Z10saveEEPROMv+0x18>
		eeprom_write_word((uint16_t*)(i * 2 + 1), param[i]);
 57a:	f8 01       	movw	r30, r16
 57c:	61 91       	ld	r22, Z+
 57e:	71 91       	ld	r23, Z+
 580:	8f 01       	movw	r16, r30
 582:	ce 01       	movw	r24, r28
 584:	c9 d4       	rcall	.+2450   	; 0xf18 <eeprom_write_word>
 586:	22 96       	adiw	r28, 0x02	; 2
}

void saveEEPROM()
{
	eeprom_write_byte((uint8_t*)0, EEPROM_FLAG);
	for (uint8_t i = 0; i < 8; i++)
 588:	c1 31       	cpi	r28, 0x11	; 17
 58a:	d1 05       	cpc	r29, r1
 58c:	a1 f7       	brne	.-24     	; 0x576 <_Z10saveEEPROMv+0x18>
	{
		eeprom_busy_wait();
		eeprom_write_word((uint16_t*)(i * 2 + 1), param[i]);
	}
}
 58e:	df 91       	pop	r29
 590:	cf 91       	pop	r28
 592:	1f 91       	pop	r17
 594:	0f 91       	pop	r16
 596:	08 95       	ret

00000598 <_Z11checkMinMaxPjh>:

void checkMinMax(uint16_t* value, uint8_t arrayIndex)
{
 598:	dc 01       	movw	r26, r24
	uint16_t max = pgm_read_word(&maxValues[arrayIndex]);
 59a:	70 e0       	ldi	r23, 0x00	; 0
 59c:	66 0f       	add	r22, r22
 59e:	77 1f       	adc	r23, r23
 5a0:	fb 01       	movw	r30, r22
 5a2:	e9 52       	subi	r30, 0x29	; 41
 5a4:	fe 4f       	sbci	r31, 0xFE	; 254
 5a6:	45 91       	lpm	r20, Z+
 5a8:	54 91       	lpm	r21, Z
	uint16_t min = pgm_read_word(&minValues[arrayIndex]);
 5aa:	fb 01       	movw	r30, r22
 5ac:	e9 51       	subi	r30, 0x19	; 25
 5ae:	fe 4f       	sbci	r31, 0xFE	; 254
 5b0:	85 91       	lpm	r24, Z+
 5b2:	94 91       	lpm	r25, Z
	
	if (*value > max)
 5b4:	2d 91       	ld	r18, X+
 5b6:	3c 91       	ld	r19, X
 5b8:	11 97       	sbiw	r26, 0x01	; 1
 5ba:	42 17       	cp	r20, r18
 5bc:	53 07       	cpc	r21, r19
 5be:	18 f4       	brcc	.+6      	; 0x5c6 <_Z11checkMinMaxPjh+0x2e>
		*value = max;
 5c0:	4d 93       	st	X+, r20
 5c2:	5c 93       	st	X, r21
 5c4:	05 c0       	rjmp	.+10     	; 0x5d0 <_Z11checkMinMaxPjh+0x38>
	else if (*value < min)
 5c6:	28 17       	cp	r18, r24
 5c8:	39 07       	cpc	r19, r25
 5ca:	28 f4       	brcc	.+10     	; 0x5d6 <_Z11checkMinMaxPjh+0x3e>
		*value = min;
 5cc:	8d 93       	st	X+, r24
 5ce:	9c 93       	st	X, r25
	else
		return;

	uart_sendString_P(PSTR("Value clipped - "));
 5d0:	82 e2       	ldi	r24, 0x22	; 34
 5d2:	90 e0       	ldi	r25, 0x00	; 0
 5d4:	64 c3       	rjmp	.+1736   	; 0xc9e <_Z17uart_sendString_PPKc>
 5d6:	08 95       	ret

000005d8 <_Z12configPortalv>:
	}
}

void configPortal(void)
{
	printData();
 5d8:	31 df       	rcall	.-414    	; 0x43c <_Z9printDatav>

				uart_sendString_P(PSTR(" set to "));

				uart_sendNumber(param[index]);

				uart_sendChar(' ');
 5da:	60 e2       	ldi	r22, 0x20	; 32
 5dc:	b6 2e       	mov	r11, r22
{
	printData();

	while (1)
	{
		if (dataReady)
 5de:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <dataReady>
 5e2:	88 23       	and	r24, r24
 5e4:	e1 f3       	breq	.-8      	; 0x5de <_Z12configPortalv+0x6>
		{
			dataReady = false;
 5e6:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <dataReady>
 5ea:	00 e0       	ldi	r16, 0x00	; 0
 5ec:	10 e0       	ldi	r17, 0x00	; 0

			for (uint8_t i = 0; i < 4; i++)
				inputBuffer[i] = tolower(inputBuffer[i]);
 5ee:	e8 01       	movw	r28, r16
 5f0:	cd 57       	subi	r28, 0x7D	; 125
 5f2:	df 4f       	sbci	r29, 0xFF	; 255
 5f4:	88 81       	ld	r24, Y
 5f6:	90 e0       	ldi	r25, 0x00	; 0
 5f8:	26 d4       	rcall	.+2124   	; 0xe46 <tolower>
 5fa:	88 83       	st	Y, r24
 5fc:	0f 5f       	subi	r16, 0xFF	; 255
 5fe:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		if (dataReady)
		{
			dataReady = false;

			for (uint8_t i = 0; i < 4; i++)
 600:	04 30       	cpi	r16, 0x04	; 4
 602:	11 05       	cpc	r17, r1
 604:	a1 f7       	brne	.-24     	; 0x5ee <_Z12configPortalv+0x16>
				inputBuffer[i] = tolower(inputBuffer[i]);

			uint32_t receivedCode = ((uint32_t)inputBuffer[0] << 24) | ((uint32_t)inputBuffer[1] << 16) | ((uint32_t)inputBuffer[2] << 8)| ((uint32_t)inputBuffer[3] << 0);
 606:	40 91 83 00 	lds	r20, 0x0083	; 0x800083 <inputBuffer>
 60a:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <inputBuffer+0x1>
 60e:	20 91 85 00 	lds	r18, 0x0085	; 0x800085 <inputBuffer+0x2>
 612:	30 91 86 00 	lds	r19, 0x0086	; 0x800086 <inputBuffer+0x3>

			int8_t index = -1;
			switch (receivedCode)
 616:	90 e0       	ldi	r25, 0x00	; 0
 618:	a0 e0       	ldi	r26, 0x00	; 0
 61a:	b0 e0       	ldi	r27, 0x00	; 0
 61c:	dc 01       	movw	r26, r24
 61e:	99 27       	eor	r25, r25
 620:	88 27       	eor	r24, r24
 622:	b4 2b       	or	r27, r20
 624:	83 2b       	or	r24, r19
 626:	92 2b       	or	r25, r18
 628:	85 36       	cpi	r24, 0x65	; 101
 62a:	22 e7       	ldi	r18, 0x72	; 114
 62c:	92 07       	cpc	r25, r18
 62e:	20 e7       	ldi	r18, 0x70	; 112
 630:	a2 07       	cpc	r26, r18
 632:	29 e6       	ldi	r18, 0x69	; 105
 634:	b2 07       	cpc	r27, r18
 636:	09 f4       	brne	.+2      	; 0x63a <_Z12configPortalv+0x62>
 638:	59 c0       	rjmp	.+178    	; 0x6ec <_Z12configPortalv+0x114>
 63a:	10 f5       	brcc	.+68     	; 0x680 <_Z12configPortalv+0xa8>
 63c:	84 37       	cpi	r24, 0x74	; 116
 63e:	29 e6       	ldi	r18, 0x69	; 105
 640:	92 07       	cpc	r25, r18
 642:	28 e7       	ldi	r18, 0x78	; 120
 644:	a2 07       	cpc	r26, r18
 646:	25 e6       	ldi	r18, 0x65	; 101
 648:	b2 07       	cpc	r27, r18
 64a:	09 f4       	brne	.+2      	; 0x64e <_Z12configPortalv+0x76>
 64c:	40 c0       	rjmp	.+128    	; 0x6ce <_Z12configPortalv+0xf6>
 64e:	40 f4       	brcc	.+16     	; 0x660 <_Z12configPortalv+0x88>
 650:	81 36       	cpi	r24, 0x61	; 97
 652:	94 47       	sbci	r25, 0x74	; 116
 654:	a1 46       	sbci	r26, 0x61	; 97
 656:	b4 46       	sbci	r27, 0x64	; 100
 658:	09 f0       	breq	.+2      	; 0x65c <_Z12configPortalv+0x84>
 65a:	4e c0       	rjmp	.+156    	; 0x6f8 <_Z12configPortalv+0x120>
			{
				case 0x64617461:		//command 'data'
					printData();
 65c:	ef de       	rcall	.-546    	; 0x43c <_Z9printDatav>
					break;
 65e:	8f c0       	rjmp	.+286    	; 0x77e <_Z12configPortalv+0x1a6>
				inputBuffer[i] = tolower(inputBuffer[i]);

			uint32_t receivedCode = ((uint32_t)inputBuffer[0] << 24) | ((uint32_t)inputBuffer[1] << 16) | ((uint32_t)inputBuffer[2] << 8)| ((uint32_t)inputBuffer[3] << 0);

			int8_t index = -1;
			switch (receivedCode)
 660:	84 37       	cpi	r24, 0x74	; 116
 662:	25 e7       	ldi	r18, 0x75	; 117
 664:	92 07       	cpc	r25, r18
 666:	23 e6       	ldi	r18, 0x63	; 99
 668:	a2 07       	cpc	r26, r18
 66a:	29 e6       	ldi	r18, 0x69	; 105
 66c:	b2 07       	cpc	r27, r18
 66e:	09 f4       	brne	.+2      	; 0x672 <_Z12configPortalv+0x9a>
 670:	3b c0       	rjmp	.+118    	; 0x6e8 <_Z12configPortalv+0x110>
 672:	88 37       	cpi	r24, 0x78	; 120
 674:	91 46       	sbci	r25, 0x61	; 97
 676:	ad 46       	sbci	r26, 0x6D	; 109
 678:	b9 46       	sbci	r27, 0x69	; 105
 67a:	09 f4       	brne	.+2      	; 0x67e <_Z12configPortalv+0xa6>
 67c:	8b c0       	rjmp	.+278    	; 0x794 <_Z12configPortalv+0x1bc>
 67e:	3c c0       	rjmp	.+120    	; 0x6f8 <_Z12configPortalv+0x120>
 680:	8e 36       	cpi	r24, 0x6E	; 110
 682:	2f e6       	ldi	r18, 0x6F	; 111
 684:	92 07       	cpc	r25, r18
 686:	23 e6       	ldi	r18, 0x63	; 99
 688:	a2 07       	cpc	r26, r18
 68a:	26 e7       	ldi	r18, 0x76	; 118
 68c:	b2 07       	cpc	r27, r18
 68e:	81 f1       	breq	.+96     	; 0x6f0 <_Z12configPortalv+0x118>
 690:	78 f4       	brcc	.+30     	; 0x6b0 <_Z12configPortalv+0xd8>
 692:	88 37       	cpi	r24, 0x78	; 120
 694:	21 e6       	ldi	r18, 0x61	; 97
 696:	92 07       	cpc	r25, r18
 698:	2d e6       	ldi	r18, 0x6D	; 109
 69a:	a2 07       	cpc	r26, r18
 69c:	24 e7       	ldi	r18, 0x74	; 116
 69e:	b2 07       	cpc	r27, r18
 6a0:	49 f1       	breq	.+82     	; 0x6f4 <_Z12configPortalv+0x11c>
 6a2:	8e 36       	cpi	r24, 0x6E	; 110
 6a4:	99 46       	sbci	r25, 0x69	; 105
 6a6:	ad 46       	sbci	r26, 0x6D	; 109
 6a8:	b4 47       	sbci	r27, 0x74	; 116
 6aa:	31 f5       	brne	.+76     	; 0x6f8 <_Z12configPortalv+0x120>
					break;
				case 0x76636f6e:		//Vcon
					index = 5;
					break;
				case 0x746d696e:		//Tmin
					index = 6;
 6ac:	d6 e0       	ldi	r29, 0x06	; 6
					break;
 6ae:	29 c0       	rjmp	.+82     	; 0x702 <_Z12configPortalv+0x12a>
				inputBuffer[i] = tolower(inputBuffer[i]);

			uint32_t receivedCode = ((uint32_t)inputBuffer[0] << 24) | ((uint32_t)inputBuffer[1] << 16) | ((uint32_t)inputBuffer[2] << 8)| ((uint32_t)inputBuffer[3] << 0);

			int8_t index = -1;
			switch (receivedCode)
 6b0:	88 37       	cpi	r24, 0x78	; 120
 6b2:	21 e6       	ldi	r18, 0x61	; 97
 6b4:	92 07       	cpc	r25, r18
 6b6:	2d e6       	ldi	r18, 0x6D	; 109
 6b8:	a2 07       	cpc	r26, r18
 6ba:	26 e7       	ldi	r18, 0x76	; 118
 6bc:	b2 07       	cpc	r27, r18
 6be:	01 f1       	breq	.+64     	; 0x700 <_Z12configPortalv+0x128>
 6c0:	85 36       	cpi	r24, 0x65	; 101
 6c2:	92 47       	sbci	r25, 0x72	; 114
 6c4:	a0 47       	sbci	r26, 0x70	; 112
 6c6:	b6 47       	sbci	r27, 0x76	; 118
 6c8:	b9 f4       	brne	.+46     	; 0x6f8 <_Z12configPortalv+0x120>
					break;
				case 0x766d6178:		//Vmax
					index = 0;
					break;
				case 0x76707265:		//Vpre
					index = 1;
 6ca:	d1 e0       	ldi	r29, 0x01	; 1
 6cc:	1a c0       	rjmp	.+52     	; 0x702 <_Z12configPortalv+0x12a>
			{
				case 0x64617461:		//command 'data'
					printData();
					break;
				case 0x65786974:		//command 'exit'
					saveEEPROM();
 6ce:	47 df       	rcall	.-370    	; 0x55e <_Z10saveEEPROMv>
					uart_sendString_P(PSTR("data saved, restarting\n"));
 6d0:	8d e8       	ldi	r24, 0x8D	; 141
 6d2:	91 e0       	ldi	r25, 0x01	; 1
 6d4:	e4 d2       	rcall	.+1480   	; 0xc9e <_Z17uart_sendString_PPKc>
				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
						_BV(WDE) | (value & 0x07)) )
				: "r0"
		);
 6d6:	98 e0       	ldi	r25, 0x08	; 8
 6d8:	88 e1       	ldi	r24, 0x18	; 24
 6da:	0f b6       	in	r0, 0x3f	; 63
 6dc:	f8 94       	cli
 6de:	a8 95       	wdr
 6e0:	81 bd       	out	0x21, r24	; 33
 6e2:	0f be       	out	0x3f, r0	; 63
 6e4:	91 bd       	out	0x21, r25	; 33
 6e6:	ff cf       	rjmp	.-2      	; 0x6e6 <_Z12configPortalv+0x10e>
					break;
				case 0x696d6178:		//Imax
					index = 2;
					break;
				case 0x69637574:		//Icut
					index = 3;
 6e8:	d3 e0       	ldi	r29, 0x03	; 3
					break;
 6ea:	0b c0       	rjmp	.+22     	; 0x702 <_Z12configPortalv+0x12a>
				case 0x69707265:		//Ipre
					index = 4;
 6ec:	d4 e0       	ldi	r29, 0x04	; 4
					break;
 6ee:	09 c0       	rjmp	.+18     	; 0x702 <_Z12configPortalv+0x12a>
				case 0x76636f6e:		//Vcon
					index = 5;
 6f0:	d5 e0       	ldi	r29, 0x05	; 5
					break;
 6f2:	07 c0       	rjmp	.+14     	; 0x702 <_Z12configPortalv+0x12a>
				case 0x746d696e:		//Tmin
					index = 6;
					break;
				case 0x746d6178:		//Tmax
					index = 7;
 6f4:	d7 e0       	ldi	r29, 0x07	; 7
					break;
 6f6:	05 c0       	rjmp	.+10     	; 0x702 <_Z12configPortalv+0x12a>
				default:
					uart_sendString_P(PSTR("Invalid command!\n"));
 6f8:	8b e7       	ldi	r24, 0x7B	; 123
 6fa:	91 e0       	ldi	r25, 0x01	; 1
 6fc:	d0 d2       	rcall	.+1440   	; 0xc9e <_Z17uart_sendString_PPKc>
 6fe:	3f c0       	rjmp	.+126    	; 0x77e <_Z12configPortalv+0x1a6>
					uart_sendString_P(PSTR("data saved, restarting\n"));
					wdt_enable(WDTO_15MS);
					while (1);
					break;
				case 0x766d6178:		//Vmax
					index = 0;
 700:	d0 e0       	ldi	r29, 0x00	; 0
					uart_sendString_P(PSTR("Invalid command!\n"));
			}

			if (index >= 0)
			{
				param[index] = convertInt();
 702:	0d 2f       	mov	r16, r29
 704:	0d 2e       	mov	r0, r29
 706:	00 0c       	add	r0, r0
 708:	11 0b       	sbc	r17, r17
 70a:	0f df       	rcall	.-482    	; 0x52a <_Z10convertIntv>
 70c:	f8 01       	movw	r30, r16
 70e:	ee 0f       	add	r30, r30
 710:	ff 1f       	adc	r31, r31
 712:	ef 58       	subi	r30, 0x8F	; 143
 714:	ff 4f       	sbci	r31, 0xFF	; 255
 716:	91 83       	std	Z+1, r25	; 0x01
 718:	80 83       	st	Z, r24
				checkMinMax(&param[index], index);
 71a:	6d 2f       	mov	r22, r29
 71c:	cf 01       	movw	r24, r30
 71e:	3c df       	rcall	.-392    	; 0x598 <_Z11checkMinMaxPjh>
				
				for (uint8_t j = 0; j < 4; j++)
					uart_sendChar(pgm_read_byte(&paramName[index * 4 + j]));
 720:	78 01       	movw	r14, r16
 722:	ee 0c       	add	r14, r14
 724:	ff 1c       	adc	r15, r15
 726:	ee 0c       	add	r14, r14
 728:	ff 1c       	adc	r15, r15
 72a:	c1 2c       	mov	r12, r1
 72c:	d1 2c       	mov	r13, r1
 72e:	f7 01       	movw	r30, r14
 730:	ec 0d       	add	r30, r12
 732:	fd 1d       	adc	r31, r13
 734:	ea 54       	subi	r30, 0x4A	; 74
 736:	fe 4f       	sbci	r31, 0xFE	; 254
 738:	84 91       	lpm	r24, Z
 73a:	7a d2       	rcall	.+1268   	; 0xc30 <_Z13uart_sendCharc>
 73c:	8f ef       	ldi	r24, 0xFF	; 255
 73e:	c8 1a       	sub	r12, r24
 740:	d8 0a       	sbc	r13, r24
			if (index >= 0)
			{
				param[index] = convertInt();
				checkMinMax(&param[index], index);
				
				for (uint8_t j = 0; j < 4; j++)
 742:	24 e0       	ldi	r18, 0x04	; 4
 744:	c2 16       	cp	r12, r18
 746:	d1 04       	cpc	r13, r1
 748:	91 f7       	brne	.-28     	; 0x72e <_Z12configPortalv+0x156>
					uart_sendChar(pgm_read_byte(&paramName[index * 4 + j]));

				uart_sendString_P(PSTR(" set to "));
 74a:	82 e7       	ldi	r24, 0x72	; 114
 74c:	91 e0       	ldi	r25, 0x01	; 1
 74e:	a7 d2       	rcall	.+1358   	; 0xc9e <_Z17uart_sendString_PPKc>

				uart_sendNumber(param[index]);
 750:	00 0f       	add	r16, r16
 752:	11 1f       	adc	r17, r17
 754:	f8 01       	movw	r30, r16
 756:	ef 58       	subi	r30, 0x8F	; 143
 758:	ff 4f       	sbci	r31, 0xFF	; 255
 75a:	6a e0       	ldi	r22, 0x0A	; 10
 75c:	80 81       	ld	r24, Z
 75e:	91 81       	ldd	r25, Z+1	; 0x01
 760:	ac d2       	rcall	.+1368   	; 0xcba <_Z15uart_sendNumberjh>

				uart_sendChar(' ');
 762:	80 e2       	ldi	r24, 0x20	; 32
 764:	65 d2       	rcall	.+1226   	; 0xc30 <_Z13uart_sendCharc>
				uart_sendChar(pgm_read_byte(&unit[index * 2]));
 766:	f8 01       	movw	r30, r16
 768:	eb 55       	subi	r30, 0x5B	; 91
 76a:	fe 4f       	sbci	r31, 0xFE	; 254
 76c:	84 91       	lpm	r24, Z
 76e:	60 d2       	rcall	.+1216   	; 0xc30 <_Z13uart_sendCharc>
				uart_sendChar(pgm_read_byte(&unit[index * 2 + 1]));
 770:	f8 01       	movw	r30, r16
 772:	ea 55       	subi	r30, 0x5A	; 90
 774:	fe 4f       	sbci	r31, 0xFE	; 254
 776:	84 91       	lpm	r24, Z
 778:	5b d2       	rcall	.+1206   	; 0xc30 <_Z13uart_sendCharc>
				uart_sendChar('\n');
 77a:	8a e0       	ldi	r24, 0x0A	; 10
 77c:	59 d2       	rcall	.+1202   	; 0xc30 <_Z13uart_sendCharc>
			{
				param[index] = convertInt();
				checkMinMax(&param[index], index);
				
				for (uint8_t j = 0; j < 4; j++)
					uart_sendChar(pgm_read_byte(&paramName[index * 4 + j]));
 77e:	80 e0       	ldi	r24, 0x00	; 0
 780:	90 e0       	ldi	r25, 0x00	; 0
				uart_sendChar(pgm_read_byte(&unit[index * 2 + 1]));
				uart_sendChar('\n');
			}
			
			for (uint8_t i = 0; i < 12; i ++)
				inputBuffer[i] = ' ';
 782:	fc 01       	movw	r30, r24
 784:	ed 57       	subi	r30, 0x7D	; 125
 786:	ff 4f       	sbci	r31, 0xFF	; 255
 788:	b0 82       	st	Z, r11
 78a:	01 96       	adiw	r24, 0x01	; 1
				uart_sendChar(pgm_read_byte(&unit[index * 2]));
				uart_sendChar(pgm_read_byte(&unit[index * 2 + 1]));
				uart_sendChar('\n');
			}
			
			for (uint8_t i = 0; i < 12; i ++)
 78c:	8c 30       	cpi	r24, 0x0C	; 12
 78e:	91 05       	cpc	r25, r1
 790:	c1 f7       	brne	.-16     	; 0x782 <_Z12configPortalv+0x1aa>
 792:	25 cf       	rjmp	.-438    	; 0x5de <_Z12configPortalv+0x6>
					break;
				case 0x76707265:		//Vpre
					index = 1;
					break;
				case 0x696d6178:		//Imax
					index = 2;
 794:	d2 e0       	ldi	r29, 0x02	; 2
 796:	b5 cf       	rjmp	.-150    	; 0x702 <_Z12configPortalv+0x12a>

00000798 <_Z21ws2812_sendarray_maskPhjhS_S_>:
#define w_nop4  w_nop2 w_nop2
#define w_nop8  w_nop4 w_nop4
#define w_nop16 w_nop8 w_nop8

void ws2812_sendarray_mask(uint8_t *data, uint16_t datlen, uint8_t maskhi, uint8_t *port, uint8_t *portreg)
{
 798:	d9 01       	movw	r26, r18
  uint8_t curbyte,ctr,masklo;
  uint8_t sreg_prev;
  
  masklo = ~maskhi & *port;
 79a:	3c 91       	ld	r19, X
 79c:	54 2f       	mov	r21, r20
 79e:	50 95       	com	r21
 7a0:	53 23       	and	r21, r19
  maskhi |= *port;
 7a2:	34 2b       	or	r19, r20
  sreg_prev=SREG;
 7a4:	2f b7       	in	r18, 0x3f	; 63
  cli();  
 7a6:	f8 94       	cli
 7a8:	fc 01       	movw	r30, r24
 7aa:	68 0f       	add	r22, r24
 7ac:	79 1f       	adc	r23, r25

  while (datlen--) {
 7ae:	e6 17       	cp	r30, r22
 7b0:	f7 07       	cpc	r31, r23
 7b2:	99 f0       	breq	.+38     	; 0x7da <skipone41+0xa>
    curbyte=*data++;
 7b4:	81 91       	ld	r24, Z+
    "       dec   %0    \n\t"    //  '1' [+4] '0' [+3]
    "       brne  loop%=\n\t"    //  '1' [+5] '0' [+4]
    :	"=&d" (ctr)
//    :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
    :	"r" (curbyte), "x" (port), "r" (maskhi), "r" (masklo)
    );
 7b6:	98 e0       	ldi	r25, 0x08	; 8

000007b8 <loop41>:
 7b8:	3c 93       	st	X, r19
 7ba:	00 c0       	rjmp	.+0      	; 0x7bc <loop41+0x4>
 7bc:	00 c0       	rjmp	.+0      	; 0x7be <loop41+0x6>
 7be:	87 ff       	sbrs	r24, 7
 7c0:	5c 93       	st	X, r21
 7c2:	88 0f       	add	r24, r24
 7c4:	00 c0       	rjmp	.+0      	; 0x7c6 <loop41+0xe>
 7c6:	00 c0       	rjmp	.+0      	; 0x7c8 <loop41+0x10>
 7c8:	00 c0       	rjmp	.+0      	; 0x7ca <loop41+0x12>
 7ca:	00 c0       	rjmp	.+0      	; 0x7cc <loop41+0x14>
 7cc:	08 f4       	brcc	.+2      	; 0x7d0 <skipone41>
 7ce:	5c 93       	st	X, r21

000007d0 <skipone41>:
 7d0:	00 00       	nop
 7d2:	00 c0       	rjmp	.+0      	; 0x7d4 <skipone41+0x4>
 7d4:	9a 95       	dec	r25
 7d6:	81 f7       	brne	.-32     	; 0x7b8 <loop41>
  masklo = ~maskhi & *port;
  maskhi |= *port;
  sreg_prev=SREG;
  cli();  

  while (datlen--) {
 7d8:	ea cf       	rjmp	.-44     	; 0x7ae <_Z21ws2812_sendarray_maskPhjhS_S_+0x16>
//    :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
    :	"r" (curbyte), "x" (port), "r" (maskhi), "r" (masklo)
    );
  }
  
  SREG=sreg_prev;
 7da:	2f bf       	out	0x3f, r18	; 63
 7dc:	08 95       	ret

000007de <main>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 7de:	2f e7       	ldi	r18, 0x7F	; 127
 7e0:	84 e8       	ldi	r24, 0x84	; 132
 7e2:	9e e1       	ldi	r25, 0x1E	; 30
 7e4:	21 50       	subi	r18, 0x01	; 1
 7e6:	80 40       	sbci	r24, 0x00	; 0
 7e8:	90 40       	sbci	r25, 0x00	; 0
 7ea:	e1 f7       	brne	.-8      	; 0x7e4 <main+0x6>
 7ec:	00 c0       	rjmp	.+0      	; 0x7ee <main+0x10>
 7ee:	00 00       	nop
int main(void)
{
    _delay_ms(500);			//give some time to the serial terminal

	//init UART
	uart_init();
 7f0:	0c d2       	rcall	.+1048   	; 0xc0a <_Z9uart_initv>
	uart_sendString_P(PSTR("\n\n\nSTART\n"));
 7f2:	80 e5       	ldi	r24, 0x50	; 80
 7f4:	93 e0       	ldi	r25, 0x03	; 3
 7f6:	53 d2       	rcall	.+1190   	; 0xc9e <_Z17uart_sendString_PPKc>

	//init TIM1 - timekeeping
	TCCR1B = (1 << WGM12) | (1 << CS10) | (1 << CS11);
 7f8:	8b e0       	ldi	r24, 0x0B	; 11
 7fa:	8e bd       	out	0x2e, r24	; 46
	OCR1A = 31250;
 7fc:	82 e1       	ldi	r24, 0x12	; 18
 7fe:	9a e7       	ldi	r25, 0x7A	; 122
 800:	9b bd       	out	0x2b, r25	; 43
 802:	8a bd       	out	0x2a, r24	; 42
	TIMSK1 = (1 << OCIE1A);
 804:	82 e0       	ldi	r24, 0x02	; 2
 806:	8c b9       	out	0x0c, r24	; 12

	sei();
 808:	78 94       	sei

	//init LED
	DDRA |= (1 << DDA5);
 80a:	d5 9a       	sbi	0x1a, 5	; 26

	if (readEEPROM())
 80c:	e8 dd       	rcall	.-1072   	; 0x3de <_Z10readEEPROMv>
 80e:	88 23       	and	r24, r24
 810:	19 f0       	breq	.+6      	; 0x818 <main+0x3a>
		uart_sendString_P(PSTR("Data loaded from EEPROM\n"));
 812:	87 e3       	ldi	r24, 0x37	; 55
 814:	93 e0       	ldi	r25, 0x03	; 3
 816:	02 c0       	rjmp	.+4      	; 0x81c <main+0x3e>
	else
		uart_sendString_P(PSTR("Nothing in EEPROM, defaults used\n"));
 818:	85 e1       	ldi	r24, 0x15	; 21
 81a:	93 e0       	ldi	r25, 0x03	; 3
 81c:	40 d2       	rcall	.+1152   	; 0xc9e <_Z17uart_sendString_PPKc>

	//check for temperature sensor
	if (adc_measurement(ADC_TEMP, 8) > 400)
 81e:	68 e0       	ldi	r22, 0x08	; 8
 820:	82 e0       	ldi	r24, 0x02	; 2
 822:	b5 dd       	rcall	.-1174   	; 0x38e <_Z15adc_measurementhh>
 824:	81 39       	cpi	r24, 0x91	; 145
 826:	91 40       	sbci	r25, 0x01	; 1
 828:	30 f0       	brcs	.+12     	; 0x836 <main+0x58>
	{
		temperature_sensor = true;
 82a:	81 e0       	ldi	r24, 0x01	; 1
 82c:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <temperature_sensor>
		uart_sendString_P(PSTR("Temperature sensor detected\n"));
 830:	88 ef       	ldi	r24, 0xF8	; 248
 832:	92 e0       	ldi	r25, 0x02	; 2
 834:	02 c0       	rjmp	.+4      	; 0x83a <main+0x5c>
	}
	else
		uart_sendString_P(PSTR("Temperature sensor not found\n"));
 836:	8a ed       	ldi	r24, 0xDA	; 218
 838:	92 e0       	ldi	r25, 0x02	; 2
 83a:	31 d2       	rcall	.+1122   	; 0xc9e <_Z17uart_sendString_PPKc>

	//wait for user to connect the battery
	uart_sendString_P(PSTR("waiting for battery connection...\n"));
 83c:	87 eb       	ldi	r24, 0xB7	; 183
 83e:	92 e0       	ldi	r25, 0x02	; 2
 840:	2e d2       	rcall	.+1116   	; 0xc9e <_Z17uart_sendString_PPKc>
			break;

		//we have received something over serial, enter setup portal
		if (dataReady)
		{
			color[2] = 128;
 842:	c0 e8       	ldi	r28, 0x80	; 128
	//wait for user to connect the battery
	uart_sendString_P(PSTR("waiting for battery connection...\n"));
	while (1)
	{
		//we have something connected, skip setup
		if ((adc_measurement(ADC_VOUT, 8) * 2) > param[Vcon])
 844:	68 e0       	ldi	r22, 0x08	; 8
 846:	80 e0       	ldi	r24, 0x00	; 0
 848:	a2 dd       	rcall	.-1212   	; 0x38e <_Z15adc_measurementhh>
 84a:	88 0f       	add	r24, r24
 84c:	99 1f       	adc	r25, r25
 84e:	20 91 7b 00 	lds	r18, 0x007B	; 0x80007b <param+0xa>
 852:	30 91 7c 00 	lds	r19, 0x007C	; 0x80007c <param+0xb>
 856:	28 17       	cp	r18, r24
 858:	39 07       	cpc	r19, r25
 85a:	e8 f1       	brcs	.+122    	; 0x8d6 <main+0xf8>
			break;

		//we have received something over serial, enter setup portal
		if (dataReady)
 85c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <dataReady>
 860:	88 23       	and	r24, r24
 862:	69 f0       	breq	.+26     	; 0x87e <main+0xa0>
		{
			color[2] = 128;
 864:	c0 93 68 00 	sts	0x0068, r28	; 0x800068 <color+0x2>
			ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 868:	0a e3       	ldi	r16, 0x3A	; 58
 86a:	10 e0       	ldi	r17, 0x00	; 0
 86c:	2b e3       	ldi	r18, 0x3B	; 59
 86e:	30 e0       	ldi	r19, 0x00	; 0
 870:	40 e2       	ldi	r20, 0x20	; 32
 872:	63 e0       	ldi	r22, 0x03	; 3
 874:	70 e0       	ldi	r23, 0x00	; 0
 876:	86 e6       	ldi	r24, 0x66	; 102
 878:	90 e0       	ldi	r25, 0x00	; 0
 87a:	8e df       	rcall	.-228    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
			configPortal();
 87c:	ad de       	rcall	.-678    	; 0x5d8 <_Z12configPortalv>
		}
		
		uart_sendString_P(PSTR("to start config, send anything via serial to the device; alternatively, connect a battery to start charging\n"));
 87e:	8a e4       	ldi	r24, 0x4A	; 74
 880:	92 e0       	ldi	r25, 0x02	; 2
 882:	0d d2       	rcall	.+1050   	; 0xc9e <_Z17uart_sendString_PPKc>
		color[2] = 128;
 884:	c0 93 68 00 	sts	0x0068, r28	; 0x800068 <color+0x2>
		ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 888:	0a e3       	ldi	r16, 0x3A	; 58
 88a:	10 e0       	ldi	r17, 0x00	; 0
 88c:	2b e3       	ldi	r18, 0x3B	; 59
 88e:	30 e0       	ldi	r19, 0x00	; 0
 890:	40 e2       	ldi	r20, 0x20	; 32
 892:	63 e0       	ldi	r22, 0x03	; 3
 894:	70 e0       	ldi	r23, 0x00	; 0
 896:	86 e6       	ldi	r24, 0x66	; 102
 898:	90 e0       	ldi	r25, 0x00	; 0
 89a:	7e df       	rcall	.-260    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
 89c:	8f e7       	ldi	r24, 0x7F	; 127
 89e:	94 e8       	ldi	r25, 0x84	; 132
 8a0:	2e e1       	ldi	r18, 0x1E	; 30
 8a2:	81 50       	subi	r24, 0x01	; 1
 8a4:	90 40       	sbci	r25, 0x00	; 0
 8a6:	20 40       	sbci	r18, 0x00	; 0
 8a8:	e1 f7       	brne	.-8      	; 0x8a2 <main+0xc4>
 8aa:	00 c0       	rjmp	.+0      	; 0x8ac <main+0xce>
 8ac:	00 00       	nop
		_delay_ms(500);
		color[2] = 0;
 8ae:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <color+0x2>
		ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 8b2:	2b e3       	ldi	r18, 0x3B	; 59
 8b4:	30 e0       	ldi	r19, 0x00	; 0
 8b6:	40 e2       	ldi	r20, 0x20	; 32
 8b8:	63 e0       	ldi	r22, 0x03	; 3
 8ba:	70 e0       	ldi	r23, 0x00	; 0
 8bc:	86 e6       	ldi	r24, 0x66	; 102
 8be:	90 e0       	ldi	r25, 0x00	; 0
 8c0:	6b df       	rcall	.-298    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
 8c2:	8f e7       	ldi	r24, 0x7F	; 127
 8c4:	94 e8       	ldi	r25, 0x84	; 132
 8c6:	2e e1       	ldi	r18, 0x1E	; 30
 8c8:	81 50       	subi	r24, 0x01	; 1
 8ca:	90 40       	sbci	r25, 0x00	; 0
 8cc:	20 40       	sbci	r18, 0x00	; 0
 8ce:	e1 f7       	brne	.-8      	; 0x8c8 <main+0xea>
 8d0:	00 c0       	rjmp	.+0      	; 0x8d2 <main+0xf4>
 8d2:	00 00       	nop
 8d4:	b7 cf       	rjmp	.-146    	; 0x844 <main+0x66>
		_delay_ms(500);
	}

	//do we need to precharge?
	if ((adc_measurement(ADC_VOUT, 16) * 2) < param[Vpre])
 8d6:	60 e1       	ldi	r22, 0x10	; 16
 8d8:	80 e0       	ldi	r24, 0x00	; 0
 8da:	59 dd       	rcall	.-1358   	; 0x38e <_Z15adc_measurementhh>
 8dc:	88 0f       	add	r24, r24
 8de:	99 1f       	adc	r25, r25
 8e0:	20 91 73 00 	lds	r18, 0x0073	; 0x800073 <param+0x2>
 8e4:	30 91 74 00 	lds	r19, 0x0074	; 0x800074 <param+0x3>
 8e8:	82 17       	cp	r24, r18
 8ea:	93 07       	cpc	r25, r19
 8ec:	98 f4       	brcc	.+38     	; 0x914 <main+0x136>
	{
		precharge = true;
 8ee:	81 e0       	ldi	r24, 0x01	; 1
 8f0:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <precharge>
		Itemp = param[Imax];
 8f4:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <param+0x4>
 8f8:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <param+0x5>
 8fc:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <Itemp+0x1>
 900:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <Itemp>
		param[Imax] = param[Ipre];
 904:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <param+0x8>
 908:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <param+0x9>
 90c:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <param+0x5>
 910:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <param+0x4>
	}

	//init TIM0 - 8 bit PWM @ 80 kHz
	TCCR0A = (1 << WGM00) | (1 << WGM01) | (1 << COM0A1) | (1 << COM0A0);
 914:	83 ec       	ldi	r24, 0xC3	; 195
 916:	80 bf       	out	0x30, r24	; 48
	DDRB |= (1 << DDB2);
 918:	ba 9a       	sbi	0x17, 2	; 23
	PWM_START;
 91a:	81 e0       	ldi	r24, 0x01	; 1
 91c:	83 bf       	out	0x33, r24	; 51

	update = true;
 91e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <update>
		if (update)
		{
			update = false;

			if (temperature_sensor)
				Tact = (((uint16_t)adc_measurement(ADC_TEMP, 8) - 400) / 20);
 922:	c4 e1       	ldi	r28, 0x14	; 20
 924:	d0 e0       	ldi	r29, 0x00	; 0
					uart_sendString_P(PSTR("==FINISHED==\n"));
					while (1);
				}
			
				//we are not finished - orange color
				color[0] = 50; color[1] = 128; color[2] = 0;
 926:	52 e3       	ldi	r21, 0x32	; 50
 928:	d5 2e       	mov	r13, r21
 92a:	60 e8       	ldi	r22, 0x80	; 128
 92c:	f6 2e       	mov	r15, r22
			int16_t Vdelta = param[Vmax] - Vact;
			int16_t Idelta = param[Imax] - Iact;
			if (precharge)
			{
				//precharge - purple color
				color[0] = 35; color[1] = 80; color[2] = 80;
 92e:	73 e2       	ldi	r23, 0x23	; 35
 930:	c7 2e       	mov	r12, r23
 932:	e0 e5       	ldi	r30, 0x50	; 80
 934:	ee 2e       	mov	r14, r30
	PWM_START;

	update = true;
    while (1)
    {
		Vact = adc_measurement(ADC_VOUT, 16) * 2;
 936:	60 e1       	ldi	r22, 0x10	; 16
 938:	80 e0       	ldi	r24, 0x00	; 0
 93a:	29 dd       	rcall	.-1454   	; 0x38e <_Z15adc_measurementhh>
 93c:	88 0f       	add	r24, r24
 93e:	99 1f       	adc	r25, r25
 940:	90 93 70 00 	sts	0x0070, r25	; 0x800070 <Vact+0x1>
 944:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <Vact>
		Iact = adc_measurement(ADC_IOUT, 16) / 2;
 948:	60 e1       	ldi	r22, 0x10	; 16
 94a:	81 e0       	ldi	r24, 0x01	; 1
 94c:	20 dd       	rcall	.-1472   	; 0x38e <_Z15adc_measurementhh>
 94e:	9c 01       	movw	r18, r24
 950:	36 95       	lsr	r19
 952:	27 95       	ror	r18
 954:	30 93 6e 00 	sts	0x006E, r19	; 0x80006e <Iact+0x1>
 958:	20 93 6d 00 	sts	0x006D, r18	; 0x80006d <Iact>

		//CC-CV regulation loop
		if (((Vact > param[Vmax]) | (Iact > param[Imax])) & (OCR0A > 0))
 95c:	e0 91 71 00 	lds	r30, 0x0071	; 0x800071 <param>
 960:	f0 91 72 00 	lds	r31, 0x0072	; 0x800072 <param+0x1>
 964:	60 91 6f 00 	lds	r22, 0x006F	; 0x80006f <Vact>
 968:	70 91 70 00 	lds	r23, 0x0070	; 0x800070 <Vact+0x1>
 96c:	40 91 75 00 	lds	r20, 0x0075	; 0x800075 <param+0x4>
 970:	50 91 76 00 	lds	r21, 0x0076	; 0x800076 <param+0x5>
 974:	a6 b7       	in	r26, 0x36	; 54
 976:	81 e0       	ldi	r24, 0x01	; 1
 978:	e6 17       	cp	r30, r22
 97a:	f7 07       	cpc	r31, r23
 97c:	08 f0       	brcs	.+2      	; 0x980 <main+0x1a2>
 97e:	80 e0       	ldi	r24, 0x00	; 0
 980:	91 e0       	ldi	r25, 0x01	; 1
 982:	42 17       	cp	r20, r18
 984:	53 07       	cpc	r21, r19
 986:	08 f0       	brcs	.+2      	; 0x98a <main+0x1ac>
 988:	90 e0       	ldi	r25, 0x00	; 0
 98a:	98 2b       	or	r25, r24
 98c:	29 f0       	breq	.+10     	; 0x998 <main+0x1ba>
 98e:	aa 23       	and	r26, r26
 990:	19 f0       	breq	.+6      	; 0x998 <main+0x1ba>
			OCR0A--;
 992:	86 b7       	in	r24, 0x36	; 54
 994:	81 50       	subi	r24, 0x01	; 1
 996:	11 c0       	rjmp	.+34     	; 0x9ba <main+0x1dc>
		else if ((Vact < param[Vmax]) & (Iact < param[Imax]) & (OCR0A < 0xFF))
 998:	a6 b7       	in	r26, 0x36	; 54
 99a:	81 e0       	ldi	r24, 0x01	; 1
 99c:	6e 17       	cp	r22, r30
 99e:	7f 07       	cpc	r23, r31
 9a0:	08 f0       	brcs	.+2      	; 0x9a4 <main+0x1c6>
 9a2:	80 e0       	ldi	r24, 0x00	; 0
 9a4:	91 e0       	ldi	r25, 0x01	; 1
 9a6:	af 3f       	cpi	r26, 0xFF	; 255
 9a8:	09 f4       	brne	.+2      	; 0x9ac <main+0x1ce>
 9aa:	90 e0       	ldi	r25, 0x00	; 0
 9ac:	98 23       	and	r25, r24
 9ae:	31 f0       	breq	.+12     	; 0x9bc <main+0x1de>
 9b0:	24 17       	cp	r18, r20
 9b2:	35 07       	cpc	r19, r21
 9b4:	18 f4       	brcc	.+6      	; 0x9bc <main+0x1de>
			OCR0A++;
 9b6:	86 b7       	in	r24, 0x36	; 54
 9b8:	8f 5f       	subi	r24, 0xFF	; 255
 9ba:	86 bf       	out	0x36, r24	; 54

		if (update)
 9bc:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <update>
 9c0:	88 23       	and	r24, r24
 9c2:	09 f4       	brne	.+2      	; 0x9c6 <main+0x1e8>
 9c4:	b8 cf       	rjmp	.-144    	; 0x936 <main+0x158>
		{
			update = false;
 9c6:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <update>

			if (temperature_sensor)
 9ca:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <temperature_sensor>
 9ce:	88 23       	and	r24, r24
 9d0:	59 f0       	breq	.+22     	; 0x9e8 <main+0x20a>
				Tact = (((uint16_t)adc_measurement(ADC_TEMP, 8) - 400) / 20);
 9d2:	68 e0       	ldi	r22, 0x08	; 8
 9d4:	82 e0       	ldi	r24, 0x02	; 2
 9d6:	db dc       	rcall	.-1610   	; 0x38e <_Z15adc_measurementhh>
 9d8:	80 59       	subi	r24, 0x90	; 144
 9da:	91 40       	sbci	r25, 0x01	; 1
 9dc:	be 01       	movw	r22, r28
 9de:	02 d2       	rcall	.+1028   	; 0xde4 <__udivmodhi4>
 9e0:	70 93 6a 00 	sts	0x006A, r23	; 0x80006a <Tact+0x1>
 9e4:	60 93 69 00 	sts	0x0069, r22	; 0x800069 <Tact>

			uart_sendString_P(PSTR("Vout: "));
 9e8:	83 e4       	ldi	r24, 0x43	; 67
 9ea:	92 e0       	ldi	r25, 0x02	; 2
 9ec:	58 d1       	rcall	.+688    	; 0xc9e <_Z17uart_sendString_PPKc>
			uart_sendNumber(Vact);
 9ee:	6a e0       	ldi	r22, 0x0A	; 10
 9f0:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <Vact>
 9f4:	90 91 70 00 	lds	r25, 0x0070	; 0x800070 <Vact+0x1>
 9f8:	60 d1       	rcall	.+704    	; 0xcba <_Z15uart_sendNumberjh>
			uart_sendString_P(PSTR(" mV; Iout: "));
 9fa:	87 e3       	ldi	r24, 0x37	; 55
 9fc:	92 e0       	ldi	r25, 0x02	; 2
 9fe:	4f d1       	rcall	.+670    	; 0xc9e <_Z17uart_sendString_PPKc>
			uart_sendNumber(Iact);
 a00:	6a e0       	ldi	r22, 0x0A	; 10
 a02:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <Iact>
 a06:	90 91 6e 00 	lds	r25, 0x006E	; 0x80006e <Iact+0x1>
 a0a:	57 d1       	rcall	.+686    	; 0xcba <_Z15uart_sendNumberjh>
			uart_sendString_P(PSTR(" mA"));
 a0c:	83 e3       	ldi	r24, 0x33	; 51
 a0e:	92 e0       	ldi	r25, 0x02	; 2
 a10:	46 d1       	rcall	.+652    	; 0xc9e <_Z17uart_sendString_PPKc>
			if (temperature_sensor)
 a12:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <temperature_sensor>
 a16:	88 23       	and	r24, r24
 a18:	61 f0       	breq	.+24     	; 0xa32 <main+0x254>
			{
				uart_sendString_P(PSTR("; t: "));
 a1a:	8d e2       	ldi	r24, 0x2D	; 45
 a1c:	92 e0       	ldi	r25, 0x02	; 2
 a1e:	3f d1       	rcall	.+638    	; 0xc9e <_Z17uart_sendString_PPKc>
				uart_sendNumber(Tact);
 a20:	6a e0       	ldi	r22, 0x0A	; 10
 a22:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <Tact>
 a26:	90 91 6a 00 	lds	r25, 0x006A	; 0x80006a <Tact+0x1>
 a2a:	47 d1       	rcall	.+654    	; 0xcba <_Z15uart_sendNumberjh>
				uart_sendString_P(PSTR(" C"));
 a2c:	8a e2       	ldi	r24, 0x2A	; 42
 a2e:	92 e0       	ldi	r25, 0x02	; 2
 a30:	36 d1       	rcall	.+620    	; 0xc9e <_Z17uart_sendString_PPKc>
			}
			uart_sendString_P(PSTR("\n"));
 a32:	88 e2       	ldi	r24, 0x28	; 40
 a34:	92 e0       	ldi	r25, 0x02	; 2
 a36:	33 d1       	rcall	.+614    	; 0xc9e <_Z17uart_sendString_PPKc>

			//precharge-CC-CV-finished determination loop
			int16_t Vdelta = param[Vmax] - Vact;
			int16_t Idelta = param[Imax] - Iact;
			if (precharge)
 a38:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <precharge>
 a3c:	88 23       	and	r24, r24
 a3e:	41 f1       	breq	.+80     	; 0xa90 <main+0x2b2>
			{
				//precharge - purple color
				color[0] = 35; color[1] = 80; color[2] = 80;
 a40:	c0 92 66 00 	sts	0x0066, r12	; 0x800066 <color>
 a44:	e0 92 67 00 	sts	0x0067, r14	; 0x800067 <color+0x1>
 a48:	e0 92 68 00 	sts	0x0068, r14	; 0x800068 <color+0x2>
				ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 a4c:	0a e3       	ldi	r16, 0x3A	; 58
 a4e:	10 e0       	ldi	r17, 0x00	; 0
 a50:	2b e3       	ldi	r18, 0x3B	; 59
 a52:	30 e0       	ldi	r19, 0x00	; 0
 a54:	40 e2       	ldi	r20, 0x20	; 32
 a56:	63 e0       	ldi	r22, 0x03	; 3
 a58:	70 e0       	ldi	r23, 0x00	; 0
 a5a:	86 e6       	ldi	r24, 0x66	; 102
 a5c:	90 e0       	ldi	r25, 0x00	; 0
 a5e:	9c de       	rcall	.-712    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>

				//are the conditions for precharging still true?
				if ((adc_measurement(ADC_VOUT, 16) * 2) > param[Vpre])
 a60:	60 e1       	ldi	r22, 0x10	; 16
 a62:	80 e0       	ldi	r24, 0x00	; 0
 a64:	94 dc       	rcall	.-1752   	; 0x38e <_Z15adc_measurementhh>
 a66:	88 0f       	add	r24, r24
 a68:	99 1f       	adc	r25, r25
 a6a:	20 91 73 00 	lds	r18, 0x0073	; 0x800073 <param+0x2>
 a6e:	30 91 74 00 	lds	r19, 0x0074	; 0x800074 <param+0x3>
 a72:	28 17       	cp	r18, r24
 a74:	39 07       	cpc	r19, r25
 a76:	08 f0       	brcs	.+2      	; 0xa7a <main+0x29c>
 a78:	5d c0       	rjmp	.+186    	; 0xb34 <main+0x356>
				{
					precharge = false;
 a7a:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <precharge>
					param[Imax] = Itemp;
 a7e:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <Itemp>
 a82:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <Itemp+0x1>
 a86:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <param+0x5>
 a8a:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <param+0x4>
 a8e:	52 c0       	rjmp	.+164    	; 0xb34 <main+0x356>
			}
			uart_sendString_P(PSTR("\n"));

			//precharge-CC-CV-finished determination loop
			int16_t Vdelta = param[Vmax] - Vact;
			int16_t Idelta = param[Imax] - Iact;
 a90:	40 91 6d 00 	lds	r20, 0x006D	; 0x80006d <Iact>
 a94:	50 91 6e 00 	lds	r21, 0x006E	; 0x80006e <Iact+0x1>
				{
					precharge = false;
					param[Imax] = Itemp;
				}
			}
			else if (abs(Vdelta) >= abs(Idelta))
 a98:	20 91 71 00 	lds	r18, 0x0071	; 0x800071 <param>
 a9c:	30 91 72 00 	lds	r19, 0x0072	; 0x800072 <param+0x1>
 aa0:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <Vact>
 aa4:	90 91 70 00 	lds	r25, 0x0070	; 0x800070 <Vact+0x1>
 aa8:	28 1b       	sub	r18, r24
 aaa:	39 0b       	sbc	r19, r25
 aac:	37 ff       	sbrs	r19, 7
 aae:	03 c0       	rjmp	.+6      	; 0xab6 <main+0x2d8>
 ab0:	31 95       	neg	r19
 ab2:	21 95       	neg	r18
 ab4:	31 09       	sbc	r19, r1
 ab6:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <param+0x4>
 aba:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <param+0x5>
 abe:	84 1b       	sub	r24, r20
 ac0:	95 0b       	sbc	r25, r21
 ac2:	97 ff       	sbrs	r25, 7
 ac4:	03 c0       	rjmp	.+6      	; 0xacc <main+0x2ee>
 ac6:	91 95       	neg	r25
 ac8:	81 95       	neg	r24
 aca:	91 09       	sbc	r25, r1
 acc:	28 17       	cp	r18, r24
 ace:	39 07       	cpc	r19, r25
 ad0:	1c f0       	brlt	.+6      	; 0xad8 <main+0x2fa>
			{
				//CC mode - red color
				color[0] = 0; color[1] = 128; color[2] = 0;
 ad2:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <color>
 ad6:	20 c0       	rjmp	.+64     	; 0xb18 <main+0x33a>
				ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
			}
			else
			{
				//CV mode
				if (Iact < param[Icut])
 ad8:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <param+0x6>
 adc:	90 91 78 00 	lds	r25, 0x0078	; 0x800078 <param+0x7>
 ae0:	48 17       	cp	r20, r24
 ae2:	59 07       	cpc	r21, r25
 ae4:	b8 f4       	brcc	.+46     	; 0xb14 <main+0x336>
				{
					//we are finished - green color
					PWM_STOP;
 ae6:	13 be       	out	0x33, r1	; 51
 ae8:	ba 98       	cbi	0x17, 2	; 23
					color[0] = 128; color[1] = 0; color[2] = 0;
 aea:	80 e8       	ldi	r24, 0x80	; 128
 aec:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <color>
 af0:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <color+0x1>
 af4:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <color+0x2>
					ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 af8:	0a e3       	ldi	r16, 0x3A	; 58
 afa:	10 e0       	ldi	r17, 0x00	; 0
 afc:	2b e3       	ldi	r18, 0x3B	; 59
 afe:	30 e0       	ldi	r19, 0x00	; 0
 b00:	40 e2       	ldi	r20, 0x20	; 32
 b02:	63 e0       	ldi	r22, 0x03	; 3
 b04:	70 e0       	ldi	r23, 0x00	; 0
 b06:	86 e6       	ldi	r24, 0x66	; 102
 b08:	90 e0       	ldi	r25, 0x00	; 0
 b0a:	46 de       	rcall	.-884    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
					uart_sendString_P(PSTR("==FINISHED==\n"));
 b0c:	8a e1       	ldi	r24, 0x1A	; 26
 b0e:	92 e0       	ldi	r25, 0x02	; 2
 b10:	c6 d0       	rcall	.+396    	; 0xc9e <_Z17uart_sendString_PPKc>
 b12:	ff cf       	rjmp	.-2      	; 0xb12 <main+0x334>
					while (1);
				}
			
				//we are not finished - orange color
				color[0] = 50; color[1] = 128; color[2] = 0;
 b14:	d0 92 66 00 	sts	0x0066, r13	; 0x800066 <color>
 b18:	f0 92 67 00 	sts	0x0067, r15	; 0x800067 <color+0x1>
 b1c:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <color+0x2>
				ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 b20:	0a e3       	ldi	r16, 0x3A	; 58
 b22:	10 e0       	ldi	r17, 0x00	; 0
 b24:	2b e3       	ldi	r18, 0x3B	; 59
 b26:	30 e0       	ldi	r19, 0x00	; 0
 b28:	40 e2       	ldi	r20, 0x20	; 32
 b2a:	63 e0       	ldi	r22, 0x03	; 3
 b2c:	70 e0       	ldi	r23, 0x00	; 0
 b2e:	86 e6       	ldi	r24, 0x66	; 102
 b30:	90 e0       	ldi	r25, 0x00	; 0
 b32:	32 de       	rcall	.-924    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
			}

			//temperature check
			if (((Tact > param[Tmax]) | (Tact < Tmin)) && temperature_sensor)
 b34:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <Tact>
 b38:	90 91 6a 00 	lds	r25, 0x006A	; 0x80006a <Tact+0x1>
 b3c:	20 91 7f 00 	lds	r18, 0x007F	; 0x80007f <param+0xe>
 b40:	30 91 80 00 	lds	r19, 0x0080	; 0x800080 <param+0xf>
 b44:	28 17       	cp	r18, r24
 b46:	39 07       	cpc	r19, r25
 b48:	18 f0       	brcs	.+6      	; 0xb50 <main+0x372>
 b4a:	06 97       	sbiw	r24, 0x06	; 6
 b4c:	08 f0       	brcs	.+2      	; 0xb50 <main+0x372>
 b4e:	f3 ce       	rjmp	.-538    	; 0x936 <main+0x158>
 b50:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <temperature_sensor>
 b54:	88 23       	and	r24, r24
 b56:	09 f4       	brne	.+2      	; 0xb5a <main+0x37c>
 b58:	ee ce       	rjmp	.-548    	; 0x936 <main+0x158>
			{
				PWM_STOP;
 b5a:	13 be       	out	0x33, r1	; 51
 b5c:	ba 98       	cbi	0x17, 2	; 23
				uart_sendString_P(PSTR("TEMPERATURE ERROR\n"));
 b5e:	87 e0       	ldi	r24, 0x07	; 7
 b60:	92 e0       	ldi	r25, 0x02	; 2
 b62:	9d d0       	rcall	.+314    	; 0xc9e <_Z17uart_sendString_PPKc>
				color[0] = 0; color[2] = 0;
 b64:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <color>
 b68:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <color+0x2>
				while(1)
				{
					color[1] = 128;
 b6c:	c0 e8       	ldi	r28, 0x80	; 128
 b6e:	c0 93 67 00 	sts	0x0067, r28	; 0x800067 <color+0x1>
					ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 b72:	0a e3       	ldi	r16, 0x3A	; 58
 b74:	10 e0       	ldi	r17, 0x00	; 0
 b76:	2b e3       	ldi	r18, 0x3B	; 59
 b78:	30 e0       	ldi	r19, 0x00	; 0
 b7a:	40 e2       	ldi	r20, 0x20	; 32
 b7c:	63 e0       	ldi	r22, 0x03	; 3
 b7e:	70 e0       	ldi	r23, 0x00	; 0
 b80:	86 e6       	ldi	r24, 0x66	; 102
 b82:	90 e0       	ldi	r25, 0x00	; 0
 b84:	09 de       	rcall	.-1006   	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
 b86:	8f e7       	ldi	r24, 0x7F	; 127
 b88:	94 e8       	ldi	r25, 0x84	; 132
 b8a:	2e e1       	ldi	r18, 0x1E	; 30
 b8c:	81 50       	subi	r24, 0x01	; 1
 b8e:	90 40       	sbci	r25, 0x00	; 0
 b90:	20 40       	sbci	r18, 0x00	; 0
 b92:	e1 f7       	brne	.-8      	; 0xb8c <main+0x3ae>
 b94:	00 c0       	rjmp	.+0      	; 0xb96 <main+0x3b8>
 b96:	00 00       	nop
					_delay_ms(500);
					color[1] = 0;
 b98:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <color+0x1>
					ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 b9c:	2b e3       	ldi	r18, 0x3B	; 59
 b9e:	30 e0       	ldi	r19, 0x00	; 0
 ba0:	40 e2       	ldi	r20, 0x20	; 32
 ba2:	63 e0       	ldi	r22, 0x03	; 3
 ba4:	70 e0       	ldi	r23, 0x00	; 0
 ba6:	86 e6       	ldi	r24, 0x66	; 102
 ba8:	90 e0       	ldi	r25, 0x00	; 0
 baa:	f6 dd       	rcall	.-1044   	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
 bac:	8f e7       	ldi	r24, 0x7F	; 127
 bae:	94 e8       	ldi	r25, 0x84	; 132
 bb0:	2e e1       	ldi	r18, 0x1E	; 30
 bb2:	81 50       	subi	r24, 0x01	; 1
 bb4:	90 40       	sbci	r25, 0x00	; 0
 bb6:	20 40       	sbci	r18, 0x00	; 0
 bb8:	e1 f7       	brne	.-8      	; 0xbb2 <main+0x3d4>
 bba:	00 c0       	rjmp	.+0      	; 0xbbc <main+0x3de>
 bbc:	00 00       	nop
 bbe:	d7 cf       	rjmp	.-82     	; 0xb6e <main+0x390>

00000bc0 <__vector_6>:
}

//interrupt each 100 ms
volatile uint8_t OVF_counter;
ISR(TIM1_COMPA_vect)
{
 bc0:	1f 92       	push	r1
 bc2:	0f 92       	push	r0
 bc4:	0f b6       	in	r0, 0x3f	; 63
 bc6:	0f 92       	push	r0
 bc8:	11 24       	eor	r1, r1
 bca:	8f 93       	push	r24
 bcc:	9f 93       	push	r25
	OVF_counter++;
 bce:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 bd2:	8f 5f       	subi	r24, 0xFF	; 255
 bd4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	if (OVF_counter >= 10)
 bd8:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 bdc:	8a 30       	cpi	r24, 0x0A	; 10
 bde:	70 f0       	brcs	.+28     	; 0xbfc <__vector_6+0x3c>
	{
		OVF_counter = 0;
 be0:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
		seconds++;
 be4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <seconds>
 be8:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <seconds+0x1>
 bec:	01 96       	adiw	r24, 0x01	; 1
 bee:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <seconds+0x1>
 bf2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <seconds>
		update = true;
 bf6:	81 e0       	ldi	r24, 0x01	; 1
 bf8:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <update>
	}
}
 bfc:	9f 91       	pop	r25
 bfe:	8f 91       	pop	r24
 c00:	0f 90       	pop	r0
 c02:	0f be       	out	0x3f, r0	; 63
 c04:	0f 90       	pop	r0
 c06:	1f 90       	pop	r1
 c08:	18 95       	reti

00000c0a <_Z9uart_initv>:
bool dataReady;

void uart_init()
{
	//setup TX pin - PA7
	DDRA |= (1 << DDA7);
 c0a:	d7 9a       	sbi	0x1a, 7	; 26
	STX_HIGH;
 c0c:	df 9a       	sbi	0x1b, 7	; 27

	//setup RX pin - PA6
	DDRA &=~(1 << DDA6);
 c0e:	d6 98       	cbi	0x1a, 6	; 26
	GIMSK |= (1 << PCIE0);
 c10:	8b b7       	in	r24, 0x3b	; 59
 c12:	80 61       	ori	r24, 0x10	; 16
 c14:	8b bf       	out	0x3b, r24	; 59
	PCMSK0 |= (1 << PCINT6);
 c16:	96 9a       	sbi	0x12, 6	; 18
 c18:	80 e0       	ldi	r24, 0x00	; 0
 c1a:	90 e0       	ldi	r25, 0x00	; 0

	//fill input buffer with predefined values
	for (uint8_t i = 0; i < 12; i++)
		inputBuffer[i] = ' ';
 c1c:	20 e2       	ldi	r18, 0x20	; 32
 c1e:	fc 01       	movw	r30, r24
 c20:	ed 57       	subi	r30, 0x7D	; 125
 c22:	ff 4f       	sbci	r31, 0xFF	; 255
 c24:	20 83       	st	Z, r18
 c26:	01 96       	adiw	r24, 0x01	; 1
	DDRA &=~(1 << DDA6);
	GIMSK |= (1 << PCIE0);
	PCMSK0 |= (1 << PCINT6);

	//fill input buffer with predefined values
	for (uint8_t i = 0; i < 12; i++)
 c28:	8c 30       	cpi	r24, 0x0C	; 12
 c2a:	91 05       	cpc	r25, r1
 c2c:	c1 f7       	brne	.-16     	; 0xc1e <_Z9uart_initv+0x14>
		inputBuffer[i] = ' ';
}
 c2e:	08 95       	ret

00000c30 <_Z13uart_sendCharc>:

void uart_sendChar(char ch)
{
	cli();
 c30:	f8 94       	cli
	STX_LOW;
 c32:	df 98       	cbi	0x1b, 7	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 c34:	e3 e0       	ldi	r30, 0x03	; 3
 c36:	f1 e0       	ldi	r31, 0x01	; 1
 c38:	31 97       	sbiw	r30, 0x01	; 1
 c3a:	f1 f7       	brne	.-4      	; 0xc38 <_Z13uart_sendCharc+0x8>
 c3c:	00 c0       	rjmp	.+0      	; 0xc3e <_Z13uart_sendCharc+0xe>
 c3e:	00 00       	nop
	_delay_us(SUART_DELAY);
	STX_HIGH;
 c40:	df 9a       	sbi	0x1b, 7	; 27
 c42:	20 e0       	ldi	r18, 0x00	; 0
 c44:	30 e0       	ldi	r19, 0x00	; 0

	for (uint8_t i = 0; i < 8; i++)
	{
		if ((ch >> i) & 0x01)
 c46:	90 e0       	ldi	r25, 0x00	; 0
 c48:	ac 01       	movw	r20, r24
 c4a:	02 2e       	mov	r0, r18
 c4c:	02 c0       	rjmp	.+4      	; 0xc52 <_Z13uart_sendCharc+0x22>
 c4e:	55 95       	asr	r21
 c50:	47 95       	ror	r20
 c52:	0a 94       	dec	r0
 c54:	e2 f7       	brpl	.-8      	; 0xc4e <_Z13uart_sendCharc+0x1e>
 c56:	40 ff       	sbrs	r20, 0
 c58:	02 c0       	rjmp	.+4      	; 0xc5e <_Z13uart_sendCharc+0x2e>
			STX_HIGH;
 c5a:	df 9a       	sbi	0x1b, 7	; 27
 c5c:	01 c0       	rjmp	.+2      	; 0xc60 <_Z13uart_sendCharc+0x30>
		else
			STX_LOW;
 c5e:	df 98       	cbi	0x1b, 7	; 27
 c60:	e3 e0       	ldi	r30, 0x03	; 3
 c62:	f1 e0       	ldi	r31, 0x01	; 1
 c64:	31 97       	sbiw	r30, 0x01	; 1
 c66:	f1 f7       	brne	.-4      	; 0xc64 <_Z13uart_sendCharc+0x34>
 c68:	00 c0       	rjmp	.+0      	; 0xc6a <_Z13uart_sendCharc+0x3a>
 c6a:	00 00       	nop
 c6c:	2f 5f       	subi	r18, 0xFF	; 255
 c6e:	3f 4f       	sbci	r19, 0xFF	; 255
	cli();
	STX_LOW;
	_delay_us(SUART_DELAY);
	STX_HIGH;

	for (uint8_t i = 0; i < 8; i++)
 c70:	28 30       	cpi	r18, 0x08	; 8
 c72:	31 05       	cpc	r19, r1
 c74:	49 f7       	brne	.-46     	; 0xc48 <_Z13uart_sendCharc+0x18>
		else
			STX_LOW;
		_delay_us(SUART_DELAY);
	}

	STX_HIGH;
 c76:	df 9a       	sbi	0x1b, 7	; 27
	sei();
 c78:	78 94       	sei
 c7a:	83 e0       	ldi	r24, 0x03	; 3
 c7c:	91 e0       	ldi	r25, 0x01	; 1
 c7e:	01 97       	sbiw	r24, 0x01	; 1
 c80:	f1 f7       	brne	.-4      	; 0xc7e <_Z13uart_sendCharc+0x4e>
 c82:	00 c0       	rjmp	.+0      	; 0xc84 <_Z13uart_sendCharc+0x54>
 c84:	00 00       	nop
 c86:	08 95       	ret

00000c88 <_Z15uart_sendStringPc>:
	_delay_us(SUART_DELAY);
}

void uart_sendString(char* s)
{
 c88:	cf 93       	push	r28
 c8a:	df 93       	push	r29
 c8c:	ec 01       	movw	r28, r24
	while(*s)  uart_sendChar(*s++);
 c8e:	89 91       	ld	r24, Y+
 c90:	88 23       	and	r24, r24
 c92:	11 f0       	breq	.+4      	; 0xc98 <_Z15uart_sendStringPc+0x10>
 c94:	cd df       	rcall	.-102    	; 0xc30 <_Z13uart_sendCharc>
 c96:	fb cf       	rjmp	.-10     	; 0xc8e <_Z15uart_sendStringPc+0x6>
}
 c98:	df 91       	pop	r29
 c9a:	cf 91       	pop	r28
 c9c:	08 95       	ret

00000c9e <_Z17uart_sendString_PPKc>:

void uart_sendString_P(const char* s)
{
 c9e:	cf 93       	push	r28
 ca0:	df 93       	push	r29
 ca2:	ec 01       	movw	r28, r24
	while (pgm_read_byte(s)) uart_sendChar(pgm_read_byte(s++));
 ca4:	fe 01       	movw	r30, r28
 ca6:	24 91       	lpm	r18, Z
 ca8:	22 23       	and	r18, r18
 caa:	21 f0       	breq	.+8      	; 0xcb4 <_Z17uart_sendString_PPKc+0x16>
 cac:	21 96       	adiw	r28, 0x01	; 1
 cae:	84 91       	lpm	r24, Z
 cb0:	bf df       	rcall	.-130    	; 0xc30 <_Z13uart_sendCharc>
 cb2:	f8 cf       	rjmp	.-16     	; 0xca4 <_Z17uart_sendString_PPKc+0x6>
}
 cb4:	df 91       	pop	r29
 cb6:	cf 91       	pop	r28
 cb8:	08 95       	ret

00000cba <_Z15uart_sendNumberjh>:

uint8_t uart_sendNumber(uint16_t num, uint8_t base)
{
 cba:	0f 93       	push	r16
 cbc:	1f 93       	push	r17
 cbe:	cf 93       	push	r28
 cc0:	df 93       	push	r29
 cc2:	00 d0       	rcall	.+0      	; 0xcc4 <_Z15uart_sendNumberjh+0xa>
 cc4:	00 d0       	rcall	.+0      	; 0xcc6 <_Z15uart_sendNumberjh+0xc>
 cc6:	00 d0       	rcall	.+0      	; 0xcc8 <_Z15uart_sendNumberjh+0xe>
 cc8:	cd b7       	in	r28, 0x3d	; 61
 cca:	de b7       	in	r29, 0x3e	; 62
 ccc:	8c 01       	movw	r16, r24
extern __inline__ __ATTR_GNU_INLINE__
char *itoa (int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__itoa (int, char *, int);
	return __itoa (__val, __s, __radix);
 cce:	46 2f       	mov	r20, r22
 cd0:	50 e0       	ldi	r21, 0x00	; 0
 cd2:	be 01       	movw	r22, r28
 cd4:	6f 5f       	subi	r22, 0xFF	; 255
 cd6:	7f 4f       	sbci	r23, 0xFF	; 255
 cd8:	be d0       	rcall	.+380    	; 0xe56 <itoa>
	char buf[6];
	itoa(num, buf, base);
	uart_sendString(buf);
 cda:	ce 01       	movw	r24, r28
 cdc:	01 96       	adiw	r24, 0x01	; 1
 cde:	d4 df       	rcall	.-88     	; 0xc88 <_Z15uart_sendStringPc>

	return (num < 10 ? 1 : (num	< 100 ? 2 : (num < 1000 ? 3 : (num < 10000 ? 4 : 5))));
 ce0:	0a 30       	cpi	r16, 0x0A	; 10
 ce2:	11 05       	cpc	r17, r1
 ce4:	60 f0       	brcs	.+24     	; 0xcfe <_Z15uart_sendNumberjh+0x44>
 ce6:	04 36       	cpi	r16, 0x64	; 100
 ce8:	11 05       	cpc	r17, r1
 cea:	58 f0       	brcs	.+22     	; 0xd02 <_Z15uart_sendNumberjh+0x48>
 cec:	08 3e       	cpi	r16, 0xE8	; 232
 cee:	83 e0       	ldi	r24, 0x03	; 3
 cf0:	18 07       	cpc	r17, r24
 cf2:	48 f0       	brcs	.+18     	; 0xd06 <_Z15uart_sendNumberjh+0x4c>
 cf4:	00 31       	cpi	r16, 0x10	; 16
 cf6:	17 42       	sbci	r17, 0x27	; 39
 cf8:	40 f0       	brcs	.+16     	; 0xd0a <_Z15uart_sendNumberjh+0x50>
 cfa:	85 e0       	ldi	r24, 0x05	; 5
 cfc:	07 c0       	rjmp	.+14     	; 0xd0c <_Z15uart_sendNumberjh+0x52>
 cfe:	81 e0       	ldi	r24, 0x01	; 1
 d00:	05 c0       	rjmp	.+10     	; 0xd0c <_Z15uart_sendNumberjh+0x52>
 d02:	82 e0       	ldi	r24, 0x02	; 2
 d04:	03 c0       	rjmp	.+6      	; 0xd0c <_Z15uart_sendNumberjh+0x52>
 d06:	83 e0       	ldi	r24, 0x03	; 3
 d08:	01 c0       	rjmp	.+2      	; 0xd0c <_Z15uart_sendNumberjh+0x52>
 d0a:	84 e0       	ldi	r24, 0x04	; 4
}
 d0c:	26 96       	adiw	r28, 0x06	; 6
 d0e:	0f b6       	in	r0, 0x3f	; 63
 d10:	f8 94       	cli
 d12:	de bf       	out	0x3e, r29	; 62
 d14:	0f be       	out	0x3f, r0	; 63
 d16:	cd bf       	out	0x3d, r28	; 61
 d18:	df 91       	pop	r29
 d1a:	cf 91       	pop	r28
 d1c:	1f 91       	pop	r17
 d1e:	0f 91       	pop	r16
 d20:	08 95       	ret

00000d22 <_Z19uart_sendCharRepeatch>:

void uart_sendCharRepeat(char ch, uint8_t repeats)
{
 d22:	1f 93       	push	r17
 d24:	cf 93       	push	r28
 d26:	df 93       	push	r29
 d28:	d8 2f       	mov	r29, r24
 d2a:	16 2f       	mov	r17, r22
	for (uint8_t i = 0; i < repeats; i ++)
 d2c:	c0 e0       	ldi	r28, 0x00	; 0
 d2e:	c1 17       	cp	r28, r17
 d30:	21 f0       	breq	.+8      	; 0xd3a <_Z19uart_sendCharRepeatch+0x18>
		uart_sendChar(ch);
 d32:	8d 2f       	mov	r24, r29
 d34:	7d df       	rcall	.-262    	; 0xc30 <_Z13uart_sendCharc>
	return (num < 10 ? 1 : (num	< 100 ? 2 : (num < 1000 ? 3 : (num < 10000 ? 4 : 5))));
}

void uart_sendCharRepeat(char ch, uint8_t repeats)
{
	for (uint8_t i = 0; i < repeats; i ++)
 d36:	cf 5f       	subi	r28, 0xFF	; 255
 d38:	fa cf       	rjmp	.-12     	; 0xd2e <_Z19uart_sendCharRepeatch+0xc>
		uart_sendChar(ch);
}
 d3a:	df 91       	pop	r29
 d3c:	cf 91       	pop	r28
 d3e:	1f 91       	pop	r17
 d40:	08 95       	ret

00000d42 <__vector_2>:

//note: putting delays in interrupts is far from ideal. However, since we are out of timers, we don't really have a choice here...
ISR(PCINT0_vect)
{
 d42:	1f 92       	push	r1
 d44:	0f 92       	push	r0
 d46:	0f b6       	in	r0, 0x3f	; 63
 d48:	0f 92       	push	r0
 d4a:	11 24       	eor	r1, r1
 d4c:	2f 93       	push	r18
 d4e:	3f 93       	push	r19
 d50:	4f 93       	push	r20
 d52:	5f 93       	push	r21
 d54:	6f 93       	push	r22
 d56:	7f 93       	push	r23
 d58:	8f 93       	push	r24
 d5a:	9f 93       	push	r25
 d5c:	ef 93       	push	r30
 d5e:	ff 93       	push	r31
	if (SRX_LOW)
 d60:	ce 99       	sbic	0x19, 6	; 25
 d62:	31 c0       	rjmp	.+98     	; 0xdc6 <__vector_2+0x84>
 d64:	85 e8       	ldi	r24, 0x85	; 133
 d66:	91 e0       	ldi	r25, 0x01	; 1
 d68:	01 97       	sbiw	r24, 0x01	; 1
 d6a:	f1 f7       	brne	.-4      	; 0xd68 <__vector_2+0x26>
 d6c:	00 c0       	rjmp	.+0      	; 0xd6e <__vector_2+0x2c>
 d6e:	00 00       	nop
 d70:	20 e0       	ldi	r18, 0x00	; 0
 d72:	30 e0       	ldi	r19, 0x00	; 0
	{
		uint8_t data = 0x0;
 d74:	80 e0       	ldi	r24, 0x00	; 0
		_delay_us(SUART_DELAY + (SUART_DELAY / 2));

		for (uint8_t i = 0; i < 8; i ++)
		{
			if (!SRX_LOW)
			data |= (1 << i);
 d76:	41 e0       	ldi	r20, 0x01	; 1
 d78:	50 e0       	ldi	r21, 0x00	; 0

		_delay_us(SUART_DELAY + (SUART_DELAY / 2));

		for (uint8_t i = 0; i < 8; i ++)
		{
			if (!SRX_LOW)
 d7a:	ce 9b       	sbis	0x19, 6	; 25
 d7c:	07 c0       	rjmp	.+14     	; 0xd8c <__vector_2+0x4a>
			data |= (1 << i);
 d7e:	ba 01       	movw	r22, r20
 d80:	02 2e       	mov	r0, r18
 d82:	01 c0       	rjmp	.+2      	; 0xd86 <__vector_2+0x44>
 d84:	66 0f       	add	r22, r22
 d86:	0a 94       	dec	r0
 d88:	ea f7       	brpl	.-6      	; 0xd84 <__vector_2+0x42>
 d8a:	86 2b       	or	r24, r22
 d8c:	e3 e0       	ldi	r30, 0x03	; 3
 d8e:	f1 e0       	ldi	r31, 0x01	; 1
 d90:	31 97       	sbiw	r30, 0x01	; 1
 d92:	f1 f7       	brne	.-4      	; 0xd90 <__vector_2+0x4e>
 d94:	00 c0       	rjmp	.+0      	; 0xd96 <__vector_2+0x54>
 d96:	00 00       	nop
 d98:	2f 5f       	subi	r18, 0xFF	; 255
 d9a:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		uint8_t data = 0x0;

		_delay_us(SUART_DELAY + (SUART_DELAY / 2));

		for (uint8_t i = 0; i < 8; i ++)
 d9c:	28 30       	cpi	r18, 0x08	; 8
 d9e:	31 05       	cpc	r19, r1
 da0:	61 f7       	brne	.-40     	; 0xd7a <__vector_2+0x38>
			if (!SRX_LOW)
			data |= (1 << i);
			_delay_us(SUART_DELAY);
		}

		if (data != '\n')
 da2:	8a 30       	cpi	r24, 0x0A	; 10
 da4:	59 f0       	breq	.+22     	; 0xdbc <__vector_2+0x7a>
			inputBuffer[bufferPos++] = data;
 da6:	e0 91 82 00 	lds	r30, 0x0082	; 0x800082 <bufferPos>
 daa:	91 e0       	ldi	r25, 0x01	; 1
 dac:	9e 0f       	add	r25, r30
 dae:	90 93 82 00 	sts	0x0082, r25	; 0x800082 <bufferPos>
 db2:	f0 e0       	ldi	r31, 0x00	; 0
 db4:	ed 57       	subi	r30, 0x7D	; 125
 db6:	ff 4f       	sbci	r31, 0xFF	; 255
 db8:	80 83       	st	Z, r24
 dba:	05 c0       	rjmp	.+10     	; 0xdc6 <__vector_2+0x84>
		else
		{
			dataReady = true;
 dbc:	81 e0       	ldi	r24, 0x01	; 1
 dbe:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <dataReady>
			bufferPos = 0;
 dc2:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <bufferPos>
		}
	}
}
 dc6:	ff 91       	pop	r31
 dc8:	ef 91       	pop	r30
 dca:	9f 91       	pop	r25
 dcc:	8f 91       	pop	r24
 dce:	7f 91       	pop	r23
 dd0:	6f 91       	pop	r22
 dd2:	5f 91       	pop	r21
 dd4:	4f 91       	pop	r20
 dd6:	3f 91       	pop	r19
 dd8:	2f 91       	pop	r18
 dda:	0f 90       	pop	r0
 ddc:	0f be       	out	0x3f, r0	; 63
 dde:	0f 90       	pop	r0
 de0:	1f 90       	pop	r1
 de2:	18 95       	reti

00000de4 <__udivmodhi4>:
 de4:	aa 1b       	sub	r26, r26
 de6:	bb 1b       	sub	r27, r27
 de8:	51 e1       	ldi	r21, 0x11	; 17
 dea:	07 c0       	rjmp	.+14     	; 0xdfa <__udivmodhi4_ep>

00000dec <__udivmodhi4_loop>:
 dec:	aa 1f       	adc	r26, r26
 dee:	bb 1f       	adc	r27, r27
 df0:	a6 17       	cp	r26, r22
 df2:	b7 07       	cpc	r27, r23
 df4:	10 f0       	brcs	.+4      	; 0xdfa <__udivmodhi4_ep>
 df6:	a6 1b       	sub	r26, r22
 df8:	b7 0b       	sbc	r27, r23

00000dfa <__udivmodhi4_ep>:
 dfa:	88 1f       	adc	r24, r24
 dfc:	99 1f       	adc	r25, r25
 dfe:	5a 95       	dec	r21
 e00:	a9 f7       	brne	.-22     	; 0xdec <__udivmodhi4_loop>
 e02:	80 95       	com	r24
 e04:	90 95       	com	r25
 e06:	bc 01       	movw	r22, r24
 e08:	cd 01       	movw	r24, r26
 e0a:	08 95       	ret

00000e0c <atoi>:
 e0c:	fc 01       	movw	r30, r24
 e0e:	88 27       	eor	r24, r24
 e10:	99 27       	eor	r25, r25
 e12:	e8 94       	clt
 e14:	21 91       	ld	r18, Z+
 e16:	20 32       	cpi	r18, 0x20	; 32
 e18:	e9 f3       	breq	.-6      	; 0xe14 <atoi+0x8>
 e1a:	29 30       	cpi	r18, 0x09	; 9
 e1c:	10 f0       	brcs	.+4      	; 0xe22 <atoi+0x16>
 e1e:	2e 30       	cpi	r18, 0x0E	; 14
 e20:	c8 f3       	brcs	.-14     	; 0xe14 <atoi+0x8>
 e22:	2b 32       	cpi	r18, 0x2B	; 43
 e24:	39 f0       	breq	.+14     	; 0xe34 <atoi+0x28>
 e26:	2d 32       	cpi	r18, 0x2D	; 45
 e28:	31 f4       	brne	.+12     	; 0xe36 <atoi+0x2a>
 e2a:	68 94       	set
 e2c:	03 c0       	rjmp	.+6      	; 0xe34 <atoi+0x28>
 e2e:	27 d0       	rcall	.+78     	; 0xe7e <__mulhi_const_10>
 e30:	82 0f       	add	r24, r18
 e32:	91 1d       	adc	r25, r1
 e34:	21 91       	ld	r18, Z+
 e36:	20 53       	subi	r18, 0x30	; 48
 e38:	2a 30       	cpi	r18, 0x0A	; 10
 e3a:	c8 f3       	brcs	.-14     	; 0xe2e <atoi+0x22>
 e3c:	1e f4       	brtc	.+6      	; 0xe44 <atoi+0x38>
 e3e:	90 95       	com	r25
 e40:	81 95       	neg	r24
 e42:	9f 4f       	sbci	r25, 0xFF	; 255
 e44:	08 95       	ret

00000e46 <tolower>:
 e46:	91 11       	cpse	r25, r1
 e48:	08 95       	ret
 e4a:	81 54       	subi	r24, 0x41	; 65
 e4c:	8a 51       	subi	r24, 0x1A	; 26
 e4e:	08 f4       	brcc	.+2      	; 0xe52 <tolower+0xc>
 e50:	80 5e       	subi	r24, 0xE0	; 224
 e52:	85 5a       	subi	r24, 0xA5	; 165
 e54:	08 95       	ret

00000e56 <itoa>:
 e56:	45 32       	cpi	r20, 0x25	; 37
 e58:	51 05       	cpc	r21, r1
 e5a:	18 f4       	brcc	.+6      	; 0xe62 <itoa+0xc>
 e5c:	42 30       	cpi	r20, 0x02	; 2
 e5e:	08 f0       	brcs	.+2      	; 0xe62 <itoa+0xc>
 e60:	04 c0       	rjmp	.+8      	; 0xe6a <__itoa_ncheck>
 e62:	fb 01       	movw	r30, r22
 e64:	10 82       	st	Z, r1
 e66:	cb 01       	movw	r24, r22
 e68:	08 95       	ret

00000e6a <__itoa_ncheck>:
 e6a:	bb 27       	eor	r27, r27
 e6c:	4a 30       	cpi	r20, 0x0A	; 10
 e6e:	31 f4       	brne	.+12     	; 0xe7c <__itoa_ncheck+0x12>
 e70:	99 23       	and	r25, r25
 e72:	22 f4       	brpl	.+8      	; 0xe7c <__itoa_ncheck+0x12>
 e74:	bd e2       	ldi	r27, 0x2D	; 45
 e76:	90 95       	com	r25
 e78:	81 95       	neg	r24
 e7a:	9f 4f       	sbci	r25, 0xFF	; 255
 e7c:	0b c0       	rjmp	.+22     	; 0xe94 <__utoa_common>

00000e7e <__mulhi_const_10>:
 e7e:	bc 01       	movw	r22, r24
 e80:	88 0f       	add	r24, r24
 e82:	99 1f       	adc	r25, r25
 e84:	88 0f       	add	r24, r24
 e86:	99 1f       	adc	r25, r25
 e88:	86 0f       	add	r24, r22
 e8a:	97 1f       	adc	r25, r23
 e8c:	88 0f       	add	r24, r24
 e8e:	99 1f       	adc	r25, r25
 e90:	08 95       	ret

00000e92 <__utoa_ncheck>:
 e92:	bb 27       	eor	r27, r27

00000e94 <__utoa_common>:
 e94:	fb 01       	movw	r30, r22
 e96:	55 27       	eor	r21, r21
 e98:	aa 27       	eor	r26, r26
 e9a:	88 0f       	add	r24, r24
 e9c:	99 1f       	adc	r25, r25
 e9e:	aa 1f       	adc	r26, r26
 ea0:	a4 17       	cp	r26, r20
 ea2:	10 f0       	brcs	.+4      	; 0xea8 <__utoa_common+0x14>
 ea4:	a4 1b       	sub	r26, r20
 ea6:	83 95       	inc	r24
 ea8:	50 51       	subi	r21, 0x10	; 16
 eaa:	b9 f7       	brne	.-18     	; 0xe9a <__utoa_common+0x6>
 eac:	a0 5d       	subi	r26, 0xD0	; 208
 eae:	aa 33       	cpi	r26, 0x3A	; 58
 eb0:	08 f0       	brcs	.+2      	; 0xeb4 <__utoa_common+0x20>
 eb2:	a9 5d       	subi	r26, 0xD9	; 217
 eb4:	a1 93       	st	Z+, r26
 eb6:	00 97       	sbiw	r24, 0x00	; 0
 eb8:	79 f7       	brne	.-34     	; 0xe98 <__utoa_common+0x4>
 eba:	b1 11       	cpse	r27, r1
 ebc:	b1 93       	st	Z+, r27
 ebe:	11 92       	st	Z+, r1
 ec0:	cb 01       	movw	r24, r22
 ec2:	00 c0       	rjmp	.+0      	; 0xec4 <strrev>

00000ec4 <strrev>:
 ec4:	dc 01       	movw	r26, r24
 ec6:	fc 01       	movw	r30, r24
 ec8:	67 2f       	mov	r22, r23
 eca:	71 91       	ld	r23, Z+
 ecc:	77 23       	and	r23, r23
 ece:	e1 f7       	brne	.-8      	; 0xec8 <strrev+0x4>
 ed0:	32 97       	sbiw	r30, 0x02	; 2
 ed2:	04 c0       	rjmp	.+8      	; 0xedc <strrev+0x18>
 ed4:	7c 91       	ld	r23, X
 ed6:	6d 93       	st	X+, r22
 ed8:	70 83       	st	Z, r23
 eda:	62 91       	ld	r22, -Z
 edc:	ae 17       	cp	r26, r30
 ede:	bf 07       	cpc	r27, r31
 ee0:	c8 f3       	brcs	.-14     	; 0xed4 <strrev+0x10>
 ee2:	08 95       	ret

00000ee4 <eeprom_read_byte>:
 ee4:	e1 99       	sbic	0x1c, 1	; 28
 ee6:	fe cf       	rjmp	.-4      	; 0xee4 <eeprom_read_byte>
 ee8:	1f ba       	out	0x1f, r1	; 31
 eea:	8e bb       	out	0x1e, r24	; 30
 eec:	e0 9a       	sbi	0x1c, 0	; 28
 eee:	99 27       	eor	r25, r25
 ef0:	8d b3       	in	r24, 0x1d	; 29
 ef2:	08 95       	ret

00000ef4 <eeprom_read_word>:
 ef4:	a8 e1       	ldi	r26, 0x18	; 24
 ef6:	b0 e0       	ldi	r27, 0x00	; 0
 ef8:	42 e0       	ldi	r20, 0x02	; 2
 efa:	13 c0       	rjmp	.+38     	; 0xf22 <eeprom_read_blraw>

00000efc <eeprom_write_byte>:
 efc:	26 2f       	mov	r18, r22

00000efe <eeprom_write_r18>:
 efe:	e1 99       	sbic	0x1c, 1	; 28
 f00:	fe cf       	rjmp	.-4      	; 0xefe <eeprom_write_r18>
 f02:	1c ba       	out	0x1c, r1	; 28
 f04:	1f ba       	out	0x1f, r1	; 31
 f06:	8e bb       	out	0x1e, r24	; 30
 f08:	2d bb       	out	0x1d, r18	; 29
 f0a:	0f b6       	in	r0, 0x3f	; 63
 f0c:	f8 94       	cli
 f0e:	e2 9a       	sbi	0x1c, 2	; 28
 f10:	e1 9a       	sbi	0x1c, 1	; 28
 f12:	0f be       	out	0x3f, r0	; 63
 f14:	01 96       	adiw	r24, 0x01	; 1
 f16:	08 95       	ret

00000f18 <eeprom_write_word>:
 f18:	f1 df       	rcall	.-30     	; 0xefc <eeprom_write_byte>
 f1a:	27 2f       	mov	r18, r23
 f1c:	f0 cf       	rjmp	.-32     	; 0xefe <eeprom_write_r18>

00000f1e <eeprom_read_block>:
 f1e:	dc 01       	movw	r26, r24
 f20:	86 2f       	mov	r24, r22

00000f22 <eeprom_read_blraw>:
 f22:	e8 2f       	mov	r30, r24
 f24:	e1 99       	sbic	0x1c, 1	; 28
 f26:	fe cf       	rjmp	.-4      	; 0xf24 <eeprom_read_blraw+0x2>
 f28:	1f ba       	out	0x1f, r1	; 31
 f2a:	05 c0       	rjmp	.+10     	; 0xf36 <eeprom_read_blraw+0x14>
 f2c:	ee bb       	out	0x1e, r30	; 30
 f2e:	e0 9a       	sbi	0x1c, 0	; 28
 f30:	e3 95       	inc	r30
 f32:	0d b2       	in	r0, 0x1d	; 29
 f34:	0d 92       	st	X+, r0
 f36:	41 50       	subi	r20, 0x01	; 1
 f38:	c8 f7       	brcc	.-14     	; 0xf2c <eeprom_read_blraw+0xa>
 f3a:	08 95       	ret

00000f3c <_exit>:
 f3c:	f8 94       	cli

00000f3e <__stop_program>:
 f3e:	ff cf       	rjmp	.-2      	; 0xf3e <__stop_program>

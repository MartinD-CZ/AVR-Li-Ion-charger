
ATtiny USB charger.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f2e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000fa2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002f  00800060  00800060  00000fa2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000fa2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000fd4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  00001010  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000020e3  00000000  00000000  000011b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ba4  00000000  00000000  0000329b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000010eb  00000000  00000000  00003e3f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000278  00000000  00000000  00004f2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007aa  00000000  00000000  000051a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001152  00000000  00000000  0000594e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000130  00000000  00000000  00006aa0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	ac c1       	rjmp	.+856    	; 0x35a <__ctors_end>
   2:	c4 c1       	rjmp	.+904    	; 0x38c <__bad_interrupt>
   4:	95 c6       	rjmp	.+3370   	; 0xd30 <__vector_2>
   6:	c2 c1       	rjmp	.+900    	; 0x38c <__bad_interrupt>
   8:	c1 c1       	rjmp	.+898    	; 0x38c <__bad_interrupt>
   a:	c0 c1       	rjmp	.+896    	; 0x38c <__bad_interrupt>
   c:	d0 c5       	rjmp	.+2976   	; 0xbae <__vector_6>
   e:	be c1       	rjmp	.+892    	; 0x38c <__bad_interrupt>
  10:	bd c1       	rjmp	.+890    	; 0x38c <__bad_interrupt>
  12:	bc c1       	rjmp	.+888    	; 0x38c <__bad_interrupt>
  14:	bb c1       	rjmp	.+886    	; 0x38c <__bad_interrupt>
  16:	ba c1       	rjmp	.+884    	; 0x38c <__bad_interrupt>
  18:	b9 c1       	rjmp	.+882    	; 0x38c <__bad_interrupt>
  1a:	b8 c1       	rjmp	.+880    	; 0x38c <__bad_interrupt>
  1c:	b7 c1       	rjmp	.+878    	; 0x38c <__bad_interrupt>
  1e:	b6 c1       	rjmp	.+876    	; 0x38c <__bad_interrupt>
  20:	b5 c1       	rjmp	.+874    	; 0x38c <__bad_interrupt>

00000022 <__trampolines_end>:
  22:	56 61       	ori	r21, 0x16	; 22
  24:	6c 75       	andi	r22, 0x5C	; 92
  26:	65 20       	and	r6, r5
  28:	63 6c       	ori	r22, 0xC3	; 195
  2a:	69 70       	andi	r22, 0x09	; 9
  2c:	70 65       	ori	r23, 0x50	; 80
  2e:	64 20       	and	r6, r4
  30:	2d 20       	and	r2, r13
	...

00000033 <_ZZ9printDatavE3__c_3>:
  33:	0a 74 6f 20 70 72 69 6e 74 20 74 68 65 20 74 61     .to print the ta
  43:	62 6c 65 20 61 67 61 69 6e 2c 20 73 65 6e 64 20     ble again, send 
  53:	44 41 54 41 3b 20 74 6f 20 73 61 76 65 20 26 20     DATA; to save & 
  63:	65 78 69 74 2c 20 73 65 6e 64 20 45 58 49 54 0a     exit, send EXIT.
	...

00000074 <_ZZ9printDatavE3__c_2>:
  74:	70 61 72 61 6d 4e 61 6d 65 20 20 20 75 6e 69 74     paramName   unit
  84:	20 20 20 20 76 61 6c 75 65 20 20 20 6d 69 6e 20         value   min 
  94:	20 20 20 20 6d 61 78 20 20 20 20 20 64 65 66 61         max     defa
  a4:	75 6c 74 0a 00                                      ult..

000000a9 <_ZZ9printDatavE3__c_1>:
  a9:	74 6f 20 63 68 61 6e 67 65 20 70 61 72 61 6d 65     to change parame
  b9:	74 65 72 73 2c 20 73 65 6e 64 3a 20 70 61 72 61     ters, send: para
  c9:	6d 4e 61 6d 65 3d 56 61 6c 75 65 20 20 20 66 6f     mName=Value   fo
  d9:	72 20 65 78 61 6d 70 6c 65 3a 20 56 6d 61 78 3d     r example: Vmax=
  e9:	34 35 30 30 0a 64 6f 20 6e 6f 74 20 66 6f 72 67     4500.do not forg
  f9:	65 74 20 74 6f 20 73 65 6e 64 20 74 68 65 20 4e     et to send the N
 109:	65 77 4c 69 6e 65 20 28 61 6b 61 20 4c 69 6e 65     ewLine (aka Line
 119:	46 65 65 64 29 20 63 68 61 72 61 63 74 65 72 20     Feed) character 
 129:	61 74 20 74 68 65 20 65 6e 64 0a 0a 00              at the end...

00000136 <_ZZ9printDatavE3__c_0>:
 136:	72 65 76 2e 20 31 2e 30 42 20 20 20 20 20 65 6d     rev. 1.0B     em
 146:	62 65 64 62 6c 6f 67 2e 65 75 0a 0a 00              bedblog.eu...

00000153 <_ZZ9printDatavE3__c>:
 153:	0a 0a 0a 3d 3d 3d 20 41 56 52 20 4c 69 2d 49 6f     ...=== AVR Li-Io
 163:	6e 20 43 68 61 72 67 65 72 20 3d 3d 3d 0a 00        n Charger ===..

00000172 <_ZZ12configPortalvE3__c_1>:
 172:	20 73 65 74 20 74 6f 20 00                           set to .

0000017b <_ZZ12configPortalvE3__c_0>:
 17b:	49 6e 76 61 6c 69 64 20 63 6f 6d 6d 61 6e 64 21     Invalid command!
 18b:	0a 00                                               ..

0000018d <_ZZ12configPortalvE3__c>:
 18d:	64 61 74 61 20 73 61 76 65 64 2c 20 72 65 73 74     data saved, rest
 19d:	61 72 74 69 6e 67 0a 00                             arting..

000001a5 <_ZL4unit>:
 1a5:	6d 56 6d 56 6d 41 6d 41 6d 41 6d 56 43 20 43 20     mVmVmAmAmAmVC C 
	...

000001b6 <_ZL9paramName>:
 1b6:	56 6d 61 78 56 70 72 65 49 6d 61 78 49 63 75 74     VmaxVpreImaxIcut
 1c6:	49 70 72 65 56 63 6f 6e 54 6d 69 6e 54 6d 61 78     IpreVconTminTmax
	...

000001d7 <_ZL9maxValues>:
 1d7:	94 11 94 11 d0 07 d0 07 d0 07 a0 0f 32 00 7d 00     ............2.}.

000001e7 <_ZL9minValues>:
 1e7:	f4 01 f4 01 64 00 0a 00 0a 00 64 00 00 00 00 00     ....d.....d.....

000001f7 <_ZL13defaultValues>:
 1f7:	68 10 b8 0b e8 03 64 00 c8 00 bc 02 00 00 2d 00     h.....d.......-.

00000207 <_ZZ4mainE3__c_12>:
 207:	54 45 4d 50 45 52 41 54 55 52 45 20 45 52 52 4f     TEMPERATURE ERRO
 217:	52 0a 00                                            R..

0000021a <_ZZ4mainE3__c_11>:
 21a:	3d 3d 46 49 4e 49 53 48 45 44 3d 3d 0a 00           ==FINISHED==..

00000228 <_ZZ4mainE3__c_10>:
 228:	0a 00                                               ..

0000022a <_ZZ4mainE3__c_9>:
 22a:	20 43 0a 00                                          C..

0000022e <_ZZ4mainE3__c_8>:
 22e:	20 6d 41 3b 20 74 3a 20 00                           mA; t: .

00000237 <_ZZ4mainE3__c_7>:
 237:	20 6d 56 3b 20 49 6f 75 74 3a 20 00                  mV; Iout: .

00000243 <_ZZ4mainE3__c_6>:
 243:	56 6f 75 74 3a 20 00                                Vout: .

0000024a <_ZZ4mainE3__c_5>:
 24a:	74 6f 20 73 74 61 72 74 20 63 6f 6e 66 69 67 2c     to start config,
 25a:	20 73 65 6e 64 20 61 6e 79 74 68 69 6e 67 20 76      send anything v
 26a:	69 61 20 73 65 72 69 61 6c 20 74 6f 20 74 68 65     ia serial to the
 27a:	20 64 65 76 69 63 65 3b 20 61 6c 74 65 72 6e 61      device; alterna
 28a:	74 69 76 65 6c 79 2c 20 63 6f 6e 6e 65 63 74 20     tively, connect 
 29a:	61 20 62 61 74 74 65 72 79 20 74 6f 20 73 74 61     a battery to sta
 2aa:	72 74 20 63 68 61 72 67 69 6e 67 0a 00              rt charging..

000002b7 <_ZZ4mainE3__c_4>:
 2b7:	77 61 69 74 69 6e 67 20 66 6f 72 20 62 61 74 74     waiting for batt
 2c7:	65 72 79 20 63 6f 6e 6e 65 63 74 69 6f 6e 2e 2e     ery connection..
 2d7:	2e 0a 00                                            ...

000002da <_ZZ4mainE3__c_3>:
 2da:	54 65 6d 70 65 72 61 74 75 72 65 20 73 65 6e 73     Temperature sens
 2ea:	6f 72 20 6e 6f 74 20 66 6f 75 6e 64 0a 00           or not found..

000002f8 <_ZZ4mainE3__c_2>:
 2f8:	54 65 6d 70 65 72 61 74 75 72 65 20 73 65 6e 73     Temperature sens
 308:	6f 72 20 64 65 74 65 63 74 65 64 0a 00              or detected..

00000315 <_ZZ4mainE3__c_1>:
 315:	4e 6f 74 68 69 6e 67 20 69 6e 20 45 45 50 52 4f     Nothing in EEPRO
 325:	4d 2c 20 64 65 66 61 75 6c 74 73 20 75 73 65 64     M, defaults used
 335:	0a 00                                               ..

00000337 <_ZZ4mainE3__c_0>:
 337:	44 61 74 61 20 6c 6f 61 64 65 64 20 66 72 6f 6d     Data loaded from
 347:	20 45 45 50 52 4f 4d 0a 00                           EEPROM..

00000350 <_ZZ4mainE3__c>:
 350:	0a 0a 0a 53 54 41 52 54 0a 00                       ...START..

0000035a <__ctors_end>:
 35a:	11 24       	eor	r1, r1
 35c:	1f be       	out	0x3f, r1	; 63
 35e:	cf e5       	ldi	r28, 0x5F	; 95
 360:	d1 e0       	ldi	r29, 0x01	; 1
 362:	de bf       	out	0x3e, r29	; 62
 364:	cd bf       	out	0x3d, r28	; 61

00000366 <_Z8wdt_initv>:
	}
}

void wdt_init(void)
{
	MCUSR = 0;
 366:	14 be       	out	0x34, r1	; 52
				"out __SREG__,__tmp_reg__"   "\n\t"
				: [TEMPREG] "=d" (temp_reg)
				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
				: "r0"
		);
 368:	0f b6       	in	r0, 0x3f	; 63
 36a:	f8 94       	cli
 36c:	a8 95       	wdr
 36e:	81 b5       	in	r24, 0x21	; 33
 370:	88 61       	ori	r24, 0x18	; 24
 372:	81 bd       	out	0x21, r24	; 33
 374:	11 bc       	out	0x21, r1	; 33
 376:	0f be       	out	0x3f, r0	; 63

00000378 <__do_clear_bss>:
 378:	20 e0       	ldi	r18, 0x00	; 0
 37a:	a0 e6       	ldi	r26, 0x60	; 96
 37c:	b0 e0       	ldi	r27, 0x00	; 0
 37e:	01 c0       	rjmp	.+2      	; 0x382 <.do_clear_bss_start>

00000380 <.do_clear_bss_loop>:
 380:	1d 92       	st	X+, r1

00000382 <.do_clear_bss_start>:
 382:	af 38       	cpi	r26, 0x8F	; 143
 384:	b2 07       	cpc	r27, r18
 386:	e1 f7       	brne	.-8      	; 0x380 <.do_clear_bss_loop>
 388:	2a d2       	rcall	.+1108   	; 0x7de <main>
 38a:	cf c5       	rjmp	.+2974   	; 0xf2a <_exit>

0000038c <__bad_interrupt>:
 38c:	39 ce       	rjmp	.-910    	; 0x0 <__vectors>

0000038e <_Z15adc_measurementhh>:
#include "..\defines.h"

//return the value of a given channel in milivolts (with a 4.096 V reference at PA0)
uint16_t adc_measurement(uint8_t channel, uint8_t samples)
{
	switch (channel)
 38e:	81 30       	cpi	r24, 0x01	; 1
 390:	39 f0       	breq	.+14     	; 0x3a0 <_Z15adc_measurementhh+0x12>
 392:	20 f0       	brcs	.+8      	; 0x39c <_Z15adc_measurementhh+0xe>
 394:	82 30       	cpi	r24, 0x02	; 2
 396:	31 f4       	brne	.+12     	; 0x3a4 <_Z15adc_measurementhh+0x16>
			break;
		case ADC_IOUT:
			ADMUX = (1 << REFS0) | (1 << MUX0) | (1 << MUX2) | (1 << MUX3);
			break;
		case ADC_TEMP:
			ADMUX = (1 << REFS0) | (1 << MUX2);
 398:	84 e4       	ldi	r24, 0x44	; 68
 39a:	03 c0       	rjmp	.+6      	; 0x3a2 <_Z15adc_measurementhh+0x14>
uint16_t adc_measurement(uint8_t channel, uint8_t samples)
{
	switch (channel)
	{
		case ADC_VOUT:
			ADMUX = (1 << REFS0) | (1 << MUX0) | (1 << MUX1);
 39c:	83 e4       	ldi	r24, 0x43	; 67
 39e:	01 c0       	rjmp	.+2      	; 0x3a2 <_Z15adc_measurementhh+0x14>
			break;
		case ADC_IOUT:
			ADMUX = (1 << REFS0) | (1 << MUX0) | (1 << MUX2) | (1 << MUX3);
 3a0:	8d e4       	ldi	r24, 0x4D	; 77
			break;
		case ADC_TEMP:
			ADMUX = (1 << REFS0) | (1 << MUX2);
 3a2:	87 b9       	out	0x07, r24	; 7
			break;
	}

	ADCSRA = (1 << ADEN) | (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
 3a4:	87 e8       	ldi	r24, 0x87	; 135
 3a6:	86 b9       	out	0x06, r24	; 6

	//start first conversion
	ADCSRA |= (1 << ADSC);
 3a8:	36 9a       	sbi	0x06, 6	; 6
	while (ADCSRA & (1 << ADSC));
 3aa:	36 99       	sbic	0x06, 6	; 6
 3ac:	fe cf       	rjmp	.-4      	; 0x3aa <_Z15adc_measurementhh+0x1c>
 3ae:	90 e0       	ldi	r25, 0x00	; 0
 3b0:	20 e0       	ldi	r18, 0x00	; 0
 3b2:	30 e0       	ldi	r19, 0x00	; 0

	uint16_t data = 0;
	for (uint8_t i = 0; i < samples; i ++)
 3b4:	96 17       	cp	r25, r22
 3b6:	49 f0       	breq	.+18     	; 0x3ca <_Z15adc_measurementhh+0x3c>
	{
		ADCSRA |= (1 << ADSC);
 3b8:	36 9a       	sbi	0x06, 6	; 6
		while (ADCSRA & (1 << ADSC));
 3ba:	36 99       	sbic	0x06, 6	; 6
 3bc:	fe cf       	rjmp	.-4      	; 0x3ba <_Z15adc_measurementhh+0x2c>
		data += ADC;
 3be:	44 b1       	in	r20, 0x04	; 4
 3c0:	55 b1       	in	r21, 0x05	; 5
 3c2:	24 0f       	add	r18, r20
 3c4:	35 1f       	adc	r19, r21
	//start first conversion
	ADCSRA |= (1 << ADSC);
	while (ADCSRA & (1 << ADSC));

	uint16_t data = 0;
	for (uint8_t i = 0; i < samples; i ++)
 3c6:	9f 5f       	subi	r25, 0xFF	; 255
 3c8:	f5 cf       	rjmp	.-22     	; 0x3b4 <_Z15adc_measurementhh+0x26>
		ADCSRA |= (1 << ADSC);
		while (ADCSRA & (1 << ADSC));
		data += ADC;
	}

	return ((data * 4) / samples);
 3ca:	22 0f       	add	r18, r18
 3cc:	33 1f       	adc	r19, r19
 3ce:	22 0f       	add	r18, r18
 3d0:	33 1f       	adc	r19, r19
 3d2:	69 2f       	mov	r22, r25
 3d4:	70 e0       	ldi	r23, 0x00	; 0
 3d6:	c9 01       	movw	r24, r18
 3d8:	fc d4       	rcall	.+2552   	; 0xdd2 <__udivmodhi4>
 3da:	cb 01       	movw	r24, r22
 3dc:	08 95       	ret

000003de <_Z10readEEPROMv>:
const char PROGMEM paramName[] = "VmaxVpreImaxIcutIpreVconTminTmax";
const char PROGMEM unit[] = "mVmVmAmAmAmVC C ";
uint16_t actValue[8];

bool readEEPROM(void)
{
 3de:	0f 93       	push	r16
 3e0:	1f 93       	push	r17
 3e2:	cf 93       	push	r28
 3e4:	df 93       	push	r29
	if (eeprom_read_byte(0) == EEPROM_FLAG)
 3e6:	80 e0       	ldi	r24, 0x00	; 0
 3e8:	90 e0       	ldi	r25, 0x00	; 0
 3ea:	73 d5       	rcall	.+2790   	; 0xed2 <eeprom_read_byte>
 3ec:	81 3a       	cpi	r24, 0xA1	; 161
 3ee:	79 f4       	brne	.+30     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
 3f0:	01 e7       	ldi	r16, 0x71	; 113
 3f2:	10 e0       	ldi	r17, 0x00	; 0
 3f4:	c1 e0       	ldi	r28, 0x01	; 1
 3f6:	d0 e0       	ldi	r29, 0x00	; 0
	{
		//we have a valid data
		for (uint8_t i = 0; i < 8; i++)
			param[i] = eeprom_read_word((const uint16_t*)(i * 2 + 1));
 3f8:	ce 01       	movw	r24, r28
 3fa:	73 d5       	rcall	.+2790   	; 0xee2 <eeprom_read_word>
 3fc:	f8 01       	movw	r30, r16
 3fe:	81 93       	st	Z+, r24
 400:	91 93       	st	Z+, r25
 402:	8f 01       	movw	r16, r30
 404:	22 96       	adiw	r28, 0x02	; 2
bool readEEPROM(void)
{
	if (eeprom_read_byte(0) == EEPROM_FLAG)
	{
		//we have a valid data
		for (uint8_t i = 0; i < 8; i++)
 406:	c1 31       	cpi	r28, 0x11	; 17
 408:	d1 05       	cpc	r29, r1
 40a:	b1 f7       	brne	.-20     	; 0x3f8 <_Z10readEEPROMv+0x1a>
 40c:	11 c0       	rjmp	.+34     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
 40e:	87 ef       	ldi	r24, 0xF7	; 247
 410:	91 e0       	ldi	r25, 0x01	; 1
 412:	a1 e7       	ldi	r26, 0x71	; 113
 414:	b0 e0       	ldi	r27, 0x00	; 0
 416:	21 e8       	ldi	r18, 0x81	; 129
 418:	30 e0       	ldi	r19, 0x00	; 0
		return true;
	}
	else
	{
		for (uint8_t i = 0; i < 8; i++)
			param[i] = pgm_read_word(&defaultValues[i]);
 41a:	fc 01       	movw	r30, r24
 41c:	45 91       	lpm	r20, Z+
 41e:	54 91       	lpm	r21, Z
 420:	4d 93       	st	X+, r20
 422:	5d 93       	st	X+, r21
 424:	02 96       	adiw	r24, 0x02	; 2

		return true;
	}
	else
	{
		for (uint8_t i = 0; i < 8; i++)
 426:	2a 17       	cp	r18, r26
 428:	3b 07       	cpc	r19, r27
 42a:	b9 f7       	brne	.-18     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
			param[i] = pgm_read_word(&defaultValues[i]);

		return false;
 42c:	80 e0       	ldi	r24, 0x00	; 0
 42e:	01 c0       	rjmp	.+2      	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
	{
		//we have a valid data
		for (uint8_t i = 0; i < 8; i++)
			param[i] = eeprom_read_word((const uint16_t*)(i * 2 + 1));

		return true;
 430:	81 e0       	ldi	r24, 0x01	; 1
		for (uint8_t i = 0; i < 8; i++)
			param[i] = pgm_read_word(&defaultValues[i]);

		return false;
	}
}
 432:	df 91       	pop	r29
 434:	cf 91       	pop	r28
 436:	1f 91       	pop	r17
 438:	0f 91       	pop	r16
 43a:	08 95       	ret

0000043c <_Z9printDatav>:
		}
	}
}

void printData(void)
{
 43c:	cf 92       	push	r12
 43e:	df 92       	push	r13
 440:	ef 92       	push	r14
 442:	ff 92       	push	r15
 444:	0f 93       	push	r16
 446:	1f 93       	push	r17
 448:	cf 93       	push	r28
 44a:	df 93       	push	r29
	dataReady = false;
 44c:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <dataReady>
	uart_sendString_P(PSTR("\n\n\n=== AVR Li-Ion Charger ===\n"));
 450:	83 e5       	ldi	r24, 0x53	; 83
 452:	91 e0       	ldi	r25, 0x01	; 1
 454:	1b d4       	rcall	.+2102   	; 0xc8c <_Z17uart_sendString_PPKc>
	uart_sendString_P(PSTR("rev. 1.0B     embedblog.eu\n\n"));
 456:	86 e3       	ldi	r24, 0x36	; 54
 458:	91 e0       	ldi	r25, 0x01	; 1
 45a:	18 d4       	rcall	.+2096   	; 0xc8c <_Z17uart_sendString_PPKc>
	uart_sendString_P(PSTR("to change parameters, send: paramName=Value   for example: Vmax=4500\ndo not forget to send the NewLine (aka LineFeed) character at the end\n\n"));
 45c:	89 ea       	ldi	r24, 0xA9	; 169
 45e:	90 e0       	ldi	r25, 0x00	; 0
 460:	15 d4       	rcall	.+2090   	; 0xc8c <_Z17uart_sendString_PPKc>
	uart_sendString_P(PSTR("paramName   unit    value   min     max     default\n"));
 462:	84 e7       	ldi	r24, 0x74	; 116
 464:	90 e0       	ldi	r25, 0x00	; 0
 466:	12 d4       	rcall	.+2084   	; 0xc8c <_Z17uart_sendString_PPKc>
 468:	91 e7       	ldi	r25, 0x71	; 113
 46a:	e9 2e       	mov	r14, r25
 46c:	90 e0       	ldi	r25, 0x00	; 0
 46e:	f9 2e       	mov	r15, r25
 470:	c0 e0       	ldi	r28, 0x00	; 0
 472:	d0 e0       	ldi	r29, 0x00	; 0
 474:	6e 01       	movw	r12, r28
 476:	cc 0c       	add	r12, r12
 478:	dd 1c       	adc	r13, r13
 47a:	00 e0       	ldi	r16, 0x00	; 0
 47c:	10 e0       	ldi	r17, 0x00	; 0

	uint8_t numLength;
	for (uint8_t i = 0; i < 8; i ++)
	{
		for (uint8_t j = 0; j < 4; j++)
			uart_sendChar(pgm_read_byte(&paramName[i * 4 + j]));
 47e:	f6 01       	movw	r30, r12
 480:	e0 0f       	add	r30, r16
 482:	f1 1f       	adc	r31, r17
 484:	ea 54       	subi	r30, 0x4A	; 74
 486:	fe 4f       	sbci	r31, 0xFE	; 254
 488:	84 91       	lpm	r24, Z
 48a:	c9 d3       	rcall	.+1938   	; 0xc1e <_Z13uart_sendCharc>
 48c:	0f 5f       	subi	r16, 0xFF	; 255
 48e:	1f 4f       	sbci	r17, 0xFF	; 255
	//characters:			12			6	    8	    8       8

	uint8_t numLength;
	for (uint8_t i = 0; i < 8; i ++)
	{
		for (uint8_t j = 0; j < 4; j++)
 490:	04 30       	cpi	r16, 0x04	; 4
 492:	11 05       	cpc	r17, r1
 494:	a1 f7       	brne	.-24     	; 0x47e <_Z9printDatav+0x42>
			uart_sendChar(pgm_read_byte(&paramName[i * 4 + j]));
		uart_sendCharRepeat(' ', 8);
 496:	68 e0       	ldi	r22, 0x08	; 8
 498:	80 e2       	ldi	r24, 0x20	; 32
 49a:	3a d4       	rcall	.+2164   	; 0xd10 <_Z19uart_sendCharRepeatch>

		uart_sendChar(pgm_read_byte(&unit[i * 2]));
 49c:	fe 01       	movw	r30, r28
 49e:	eb 55       	subi	r30, 0x5B	; 91
 4a0:	fe 4f       	sbci	r31, 0xFE	; 254
 4a2:	84 91       	lpm	r24, Z
 4a4:	bc d3       	rcall	.+1912   	; 0xc1e <_Z13uart_sendCharc>
		uart_sendChar(pgm_read_byte(&unit[i * 2 + 1]));
 4a6:	fe 01       	movw	r30, r28
 4a8:	ea 55       	subi	r30, 0x5A	; 90
 4aa:	fe 4f       	sbci	r31, 0xFE	; 254
 4ac:	84 91       	lpm	r24, Z
 4ae:	b7 d3       	rcall	.+1902   	; 0xc1e <_Z13uart_sendCharc>
		uart_sendCharRepeat(' ', 6);
 4b0:	66 e0       	ldi	r22, 0x06	; 6
 4b2:	80 e2       	ldi	r24, 0x20	; 32
 4b4:	2d d4       	rcall	.+2138   	; 0xd10 <_Z19uart_sendCharRepeatch>

		numLength = uart_sendNumber(param[i]);
 4b6:	6a e0       	ldi	r22, 0x0A	; 10
 4b8:	f7 01       	movw	r30, r14
 4ba:	81 91       	ld	r24, Z+
 4bc:	91 91       	ld	r25, Z+
 4be:	7f 01       	movw	r14, r30
 4c0:	f3 d3       	rcall	.+2022   	; 0xca8 <_Z15uart_sendNumberjh>
		uart_sendCharRepeat(' ', 8 - numLength);
 4c2:	18 e0       	ldi	r17, 0x08	; 8
 4c4:	61 2f       	mov	r22, r17
 4c6:	68 1b       	sub	r22, r24
 4c8:	80 e2       	ldi	r24, 0x20	; 32
 4ca:	22 d4       	rcall	.+2116   	; 0xd10 <_Z19uart_sendCharRepeatch>

		numLength = uart_sendNumber(pgm_read_word(&minValues[i]));
 4cc:	fe 01       	movw	r30, r28
 4ce:	e9 51       	subi	r30, 0x19	; 25
 4d0:	fe 4f       	sbci	r31, 0xFE	; 254
 4d2:	85 91       	lpm	r24, Z+
 4d4:	94 91       	lpm	r25, Z
 4d6:	6a e0       	ldi	r22, 0x0A	; 10
 4d8:	e7 d3       	rcall	.+1998   	; 0xca8 <_Z15uart_sendNumberjh>
		uart_sendCharRepeat(' ', 8 - numLength);
 4da:	61 2f       	mov	r22, r17
 4dc:	68 1b       	sub	r22, r24
 4de:	80 e2       	ldi	r24, 0x20	; 32
 4e0:	17 d4       	rcall	.+2094   	; 0xd10 <_Z19uart_sendCharRepeatch>

		numLength = uart_sendNumber(pgm_read_word(&maxValues[i]));
 4e2:	fe 01       	movw	r30, r28
 4e4:	e9 52       	subi	r30, 0x29	; 41
 4e6:	fe 4f       	sbci	r31, 0xFE	; 254
 4e8:	85 91       	lpm	r24, Z+
 4ea:	94 91       	lpm	r25, Z
 4ec:	6a e0       	ldi	r22, 0x0A	; 10
 4ee:	dc d3       	rcall	.+1976   	; 0xca8 <_Z15uart_sendNumberjh>
		uart_sendCharRepeat(' ', 8 - numLength);
 4f0:	61 2f       	mov	r22, r17
 4f2:	68 1b       	sub	r22, r24
 4f4:	80 e2       	ldi	r24, 0x20	; 32
 4f6:	0c d4       	rcall	.+2072   	; 0xd10 <_Z19uart_sendCharRepeatch>

		uart_sendNumber(pgm_read_word(&defaultValues[i]));
 4f8:	fe 01       	movw	r30, r28
 4fa:	e9 50       	subi	r30, 0x09	; 9
 4fc:	fe 4f       	sbci	r31, 0xFE	; 254
 4fe:	85 91       	lpm	r24, Z+
 500:	94 91       	lpm	r25, Z
 502:	6a e0       	ldi	r22, 0x0A	; 10
 504:	d1 d3       	rcall	.+1954   	; 0xca8 <_Z15uart_sendNumberjh>
		uart_sendChar('\n');
 506:	8a e0       	ldi	r24, 0x0A	; 10
 508:	8a d3       	rcall	.+1812   	; 0xc1e <_Z13uart_sendCharc>
 50a:	22 96       	adiw	r28, 0x02	; 2
	uart_sendString_P(PSTR("to change parameters, send: paramName=Value   for example: Vmax=4500\ndo not forget to send the NewLine (aka LineFeed) character at the end\n\n"));
	uart_sendString_P(PSTR("paramName   unit    value   min     max     default\n"));
	//characters:			12			6	    8	    8       8

	uint8_t numLength;
	for (uint8_t i = 0; i < 8; i ++)
 50c:	c0 31       	cpi	r28, 0x10	; 16
 50e:	d1 05       	cpc	r29, r1
 510:	09 f0       	breq	.+2      	; 0x514 <_Z9printDatav+0xd8>
 512:	b0 cf       	rjmp	.-160    	; 0x474 <_Z9printDatav+0x38>

		uart_sendNumber(pgm_read_word(&defaultValues[i]));
		uart_sendChar('\n');
	}

	uart_sendString_P(PSTR("\nto print the table again, send DATA; to save & exit, send EXIT\n"));
 514:	83 e3       	ldi	r24, 0x33	; 51
 516:	90 e0       	ldi	r25, 0x00	; 0
}
 518:	df 91       	pop	r29
 51a:	cf 91       	pop	r28
 51c:	1f 91       	pop	r17
 51e:	0f 91       	pop	r16
 520:	ff 90       	pop	r15
 522:	ef 90       	pop	r14
 524:	df 90       	pop	r13
 526:	cf 90       	pop	r12

		uart_sendNumber(pgm_read_word(&defaultValues[i]));
		uart_sendChar('\n');
	}

	uart_sendString_P(PSTR("\nto print the table again, send DATA; to save & exit, send EXIT\n"));
 528:	b1 c3       	rjmp	.+1890   	; 0xc8c <_Z17uart_sendString_PPKc>

0000052a <_Z10convertIntv>:
}

uint16_t convertInt()
{
 52a:	cf 93       	push	r28
 52c:	df 93       	push	r29
 52e:	00 d0       	rcall	.+0      	; 0x530 <_Z10convertIntv+0x6>
 530:	00 d0       	rcall	.+0      	; 0x532 <_Z10convertIntv+0x8>
 532:	cd b7       	in	r28, 0x3d	; 61
 534:	de b7       	in	r29, 0x3e	; 62
	char number[4];

	for (uint8_t i = 0; i < 4; i ++)
		number[i] = inputBuffer[5 + i];
 536:	e3 e8       	ldi	r30, 0x83	; 131
 538:	f0 e0       	ldi	r31, 0x00	; 0
 53a:	85 81       	ldd	r24, Z+5	; 0x05
 53c:	89 83       	std	Y+1, r24	; 0x01
 53e:	86 81       	ldd	r24, Z+6	; 0x06
 540:	8a 83       	std	Y+2, r24	; 0x02
 542:	87 81       	ldd	r24, Z+7	; 0x07
 544:	8b 83       	std	Y+3, r24	; 0x03
 546:	80 85       	ldd	r24, Z+8	; 0x08
 548:	8c 83       	std	Y+4, r24	; 0x04

	uint16_t result = atoi(number);
 54a:	ce 01       	movw	r24, r28
 54c:	01 96       	adiw	r24, 0x01	; 1
 54e:	55 d4       	rcall	.+2218   	; 0xdfa <atoi>
	return result;
}
 550:	0f 90       	pop	r0
 552:	0f 90       	pop	r0
 554:	0f 90       	pop	r0
 556:	0f 90       	pop	r0
 558:	df 91       	pop	r29
 55a:	cf 91       	pop	r28
 55c:	08 95       	ret

0000055e <_Z10saveEEPROMv>:

void saveEEPROM()
{
 55e:	0f 93       	push	r16
 560:	1f 93       	push	r17
 562:	cf 93       	push	r28
 564:	df 93       	push	r29
	eeprom_write_byte((uint8_t*)0, EEPROM_FLAG);
 566:	61 ea       	ldi	r22, 0xA1	; 161
 568:	80 e0       	ldi	r24, 0x00	; 0
 56a:	90 e0       	ldi	r25, 0x00	; 0
 56c:	be d4       	rcall	.+2428   	; 0xeea <eeprom_write_byte>
 56e:	01 e7       	ldi	r16, 0x71	; 113
 570:	10 e0       	ldi	r17, 0x00	; 0
 572:	c1 e0       	ldi	r28, 0x01	; 1
 574:	d0 e0       	ldi	r29, 0x00	; 0
	for (uint8_t i = 0; i < 8; i++)
	{
		eeprom_busy_wait();
 576:	e1 99       	sbic	0x1c, 1	; 28
 578:	fe cf       	rjmp	.-4      	; 0x576 <_Z10saveEEPROMv+0x18>
		eeprom_write_word((uint16_t*)(i * 2 + 1), param[i]);
 57a:	f8 01       	movw	r30, r16
 57c:	61 91       	ld	r22, Z+
 57e:	71 91       	ld	r23, Z+
 580:	8f 01       	movw	r16, r30
 582:	ce 01       	movw	r24, r28
 584:	c0 d4       	rcall	.+2432   	; 0xf06 <eeprom_write_word>
 586:	22 96       	adiw	r28, 0x02	; 2
}

void saveEEPROM()
{
	eeprom_write_byte((uint8_t*)0, EEPROM_FLAG);
	for (uint8_t i = 0; i < 8; i++)
 588:	c1 31       	cpi	r28, 0x11	; 17
 58a:	d1 05       	cpc	r29, r1
 58c:	a1 f7       	brne	.-24     	; 0x576 <_Z10saveEEPROMv+0x18>
	{
		eeprom_busy_wait();
		eeprom_write_word((uint16_t*)(i * 2 + 1), param[i]);
	}
}
 58e:	df 91       	pop	r29
 590:	cf 91       	pop	r28
 592:	1f 91       	pop	r17
 594:	0f 91       	pop	r16
 596:	08 95       	ret

00000598 <_Z11checkMinMaxPjh>:

void checkMinMax(uint16_t* value, uint8_t arrayIndex)
{
 598:	dc 01       	movw	r26, r24
	uint16_t max = pgm_read_word(&maxValues[arrayIndex]);
 59a:	70 e0       	ldi	r23, 0x00	; 0
 59c:	66 0f       	add	r22, r22
 59e:	77 1f       	adc	r23, r23
 5a0:	fb 01       	movw	r30, r22
 5a2:	e9 52       	subi	r30, 0x29	; 41
 5a4:	fe 4f       	sbci	r31, 0xFE	; 254
 5a6:	45 91       	lpm	r20, Z+
 5a8:	54 91       	lpm	r21, Z
	uint16_t min = pgm_read_word(&minValues[arrayIndex]);
 5aa:	fb 01       	movw	r30, r22
 5ac:	e9 51       	subi	r30, 0x19	; 25
 5ae:	fe 4f       	sbci	r31, 0xFE	; 254
 5b0:	85 91       	lpm	r24, Z+
 5b2:	94 91       	lpm	r25, Z
	
	if (*value > max)
 5b4:	2d 91       	ld	r18, X+
 5b6:	3c 91       	ld	r19, X
 5b8:	11 97       	sbiw	r26, 0x01	; 1
 5ba:	42 17       	cp	r20, r18
 5bc:	53 07       	cpc	r21, r19
 5be:	18 f4       	brcc	.+6      	; 0x5c6 <_Z11checkMinMaxPjh+0x2e>
		*value = max;
 5c0:	4d 93       	st	X+, r20
 5c2:	5c 93       	st	X, r21
 5c4:	05 c0       	rjmp	.+10     	; 0x5d0 <_Z11checkMinMaxPjh+0x38>
	else if (*value < min)
 5c6:	28 17       	cp	r18, r24
 5c8:	39 07       	cpc	r19, r25
 5ca:	28 f4       	brcc	.+10     	; 0x5d6 <_Z11checkMinMaxPjh+0x3e>
		*value = min;
 5cc:	8d 93       	st	X+, r24
 5ce:	9c 93       	st	X, r25
	else
		return;

	uart_sendString_P(PSTR("Value clipped - "));
 5d0:	82 e2       	ldi	r24, 0x22	; 34
 5d2:	90 e0       	ldi	r25, 0x00	; 0
 5d4:	5b c3       	rjmp	.+1718   	; 0xc8c <_Z17uart_sendString_PPKc>
 5d6:	08 95       	ret

000005d8 <_Z12configPortalv>:
	}
}

void configPortal(void)
{
	printData();
 5d8:	31 df       	rcall	.-414    	; 0x43c <_Z9printDatav>

				uart_sendString_P(PSTR(" set to "));

				uart_sendNumber(param[index]);

				uart_sendChar(' ');
 5da:	60 e2       	ldi	r22, 0x20	; 32
 5dc:	b6 2e       	mov	r11, r22
{
	printData();

	while (1)
	{
		if (dataReady)
 5de:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <dataReady>
 5e2:	88 23       	and	r24, r24
 5e4:	e1 f3       	breq	.-8      	; 0x5de <_Z12configPortalv+0x6>
		{
			dataReady = false;
 5e6:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <dataReady>
 5ea:	00 e0       	ldi	r16, 0x00	; 0
 5ec:	10 e0       	ldi	r17, 0x00	; 0

			for (uint8_t i = 0; i < 4; i++)
				inputBuffer[i] = tolower(inputBuffer[i]);
 5ee:	e8 01       	movw	r28, r16
 5f0:	cd 57       	subi	r28, 0x7D	; 125
 5f2:	df 4f       	sbci	r29, 0xFF	; 255
 5f4:	88 81       	ld	r24, Y
 5f6:	90 e0       	ldi	r25, 0x00	; 0
 5f8:	1d d4       	rcall	.+2106   	; 0xe34 <tolower>
 5fa:	88 83       	st	Y, r24
 5fc:	0f 5f       	subi	r16, 0xFF	; 255
 5fe:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		if (dataReady)
		{
			dataReady = false;

			for (uint8_t i = 0; i < 4; i++)
 600:	04 30       	cpi	r16, 0x04	; 4
 602:	11 05       	cpc	r17, r1
 604:	a1 f7       	brne	.-24     	; 0x5ee <_Z12configPortalv+0x16>
				inputBuffer[i] = tolower(inputBuffer[i]);

			uint32_t receivedCode = ((uint32_t)inputBuffer[0] << 24) | ((uint32_t)inputBuffer[1] << 16) | ((uint32_t)inputBuffer[2] << 8)| ((uint32_t)inputBuffer[3] << 0);
 606:	40 91 83 00 	lds	r20, 0x0083	; 0x800083 <inputBuffer>
 60a:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <inputBuffer+0x1>
 60e:	20 91 85 00 	lds	r18, 0x0085	; 0x800085 <inputBuffer+0x2>
 612:	30 91 86 00 	lds	r19, 0x0086	; 0x800086 <inputBuffer+0x3>

			int8_t index = -1;
			switch (receivedCode)
 616:	90 e0       	ldi	r25, 0x00	; 0
 618:	a0 e0       	ldi	r26, 0x00	; 0
 61a:	b0 e0       	ldi	r27, 0x00	; 0
 61c:	dc 01       	movw	r26, r24
 61e:	99 27       	eor	r25, r25
 620:	88 27       	eor	r24, r24
 622:	b4 2b       	or	r27, r20
 624:	83 2b       	or	r24, r19
 626:	92 2b       	or	r25, r18
 628:	85 36       	cpi	r24, 0x65	; 101
 62a:	22 e7       	ldi	r18, 0x72	; 114
 62c:	92 07       	cpc	r25, r18
 62e:	20 e7       	ldi	r18, 0x70	; 112
 630:	a2 07       	cpc	r26, r18
 632:	29 e6       	ldi	r18, 0x69	; 105
 634:	b2 07       	cpc	r27, r18
 636:	09 f4       	brne	.+2      	; 0x63a <_Z12configPortalv+0x62>
 638:	59 c0       	rjmp	.+178    	; 0x6ec <_Z12configPortalv+0x114>
 63a:	10 f5       	brcc	.+68     	; 0x680 <_Z12configPortalv+0xa8>
 63c:	84 37       	cpi	r24, 0x74	; 116
 63e:	29 e6       	ldi	r18, 0x69	; 105
 640:	92 07       	cpc	r25, r18
 642:	28 e7       	ldi	r18, 0x78	; 120
 644:	a2 07       	cpc	r26, r18
 646:	25 e6       	ldi	r18, 0x65	; 101
 648:	b2 07       	cpc	r27, r18
 64a:	09 f4       	brne	.+2      	; 0x64e <_Z12configPortalv+0x76>
 64c:	40 c0       	rjmp	.+128    	; 0x6ce <_Z12configPortalv+0xf6>
 64e:	40 f4       	brcc	.+16     	; 0x660 <_Z12configPortalv+0x88>
 650:	81 36       	cpi	r24, 0x61	; 97
 652:	94 47       	sbci	r25, 0x74	; 116
 654:	a1 46       	sbci	r26, 0x61	; 97
 656:	b4 46       	sbci	r27, 0x64	; 100
 658:	09 f0       	breq	.+2      	; 0x65c <_Z12configPortalv+0x84>
 65a:	4e c0       	rjmp	.+156    	; 0x6f8 <_Z12configPortalv+0x120>
			{
				case 0x64617461:		//command 'data'
					printData();
 65c:	ef de       	rcall	.-546    	; 0x43c <_Z9printDatav>
					break;
 65e:	8f c0       	rjmp	.+286    	; 0x77e <_Z12configPortalv+0x1a6>
				inputBuffer[i] = tolower(inputBuffer[i]);

			uint32_t receivedCode = ((uint32_t)inputBuffer[0] << 24) | ((uint32_t)inputBuffer[1] << 16) | ((uint32_t)inputBuffer[2] << 8)| ((uint32_t)inputBuffer[3] << 0);

			int8_t index = -1;
			switch (receivedCode)
 660:	84 37       	cpi	r24, 0x74	; 116
 662:	25 e7       	ldi	r18, 0x75	; 117
 664:	92 07       	cpc	r25, r18
 666:	23 e6       	ldi	r18, 0x63	; 99
 668:	a2 07       	cpc	r26, r18
 66a:	29 e6       	ldi	r18, 0x69	; 105
 66c:	b2 07       	cpc	r27, r18
 66e:	09 f4       	brne	.+2      	; 0x672 <_Z12configPortalv+0x9a>
 670:	3b c0       	rjmp	.+118    	; 0x6e8 <_Z12configPortalv+0x110>
 672:	88 37       	cpi	r24, 0x78	; 120
 674:	91 46       	sbci	r25, 0x61	; 97
 676:	ad 46       	sbci	r26, 0x6D	; 109
 678:	b9 46       	sbci	r27, 0x69	; 105
 67a:	09 f4       	brne	.+2      	; 0x67e <_Z12configPortalv+0xa6>
 67c:	8b c0       	rjmp	.+278    	; 0x794 <_Z12configPortalv+0x1bc>
 67e:	3c c0       	rjmp	.+120    	; 0x6f8 <_Z12configPortalv+0x120>
 680:	8e 36       	cpi	r24, 0x6E	; 110
 682:	2f e6       	ldi	r18, 0x6F	; 111
 684:	92 07       	cpc	r25, r18
 686:	23 e6       	ldi	r18, 0x63	; 99
 688:	a2 07       	cpc	r26, r18
 68a:	26 e7       	ldi	r18, 0x76	; 118
 68c:	b2 07       	cpc	r27, r18
 68e:	81 f1       	breq	.+96     	; 0x6f0 <_Z12configPortalv+0x118>
 690:	78 f4       	brcc	.+30     	; 0x6b0 <_Z12configPortalv+0xd8>
 692:	88 37       	cpi	r24, 0x78	; 120
 694:	21 e6       	ldi	r18, 0x61	; 97
 696:	92 07       	cpc	r25, r18
 698:	2d e6       	ldi	r18, 0x6D	; 109
 69a:	a2 07       	cpc	r26, r18
 69c:	24 e7       	ldi	r18, 0x74	; 116
 69e:	b2 07       	cpc	r27, r18
 6a0:	49 f1       	breq	.+82     	; 0x6f4 <_Z12configPortalv+0x11c>
 6a2:	8e 36       	cpi	r24, 0x6E	; 110
 6a4:	99 46       	sbci	r25, 0x69	; 105
 6a6:	ad 46       	sbci	r26, 0x6D	; 109
 6a8:	b4 47       	sbci	r27, 0x74	; 116
 6aa:	31 f5       	brne	.+76     	; 0x6f8 <_Z12configPortalv+0x120>
					break;
				case 0x76636f6e:		//Vcon
					index = 5;
					break;
				case 0x746d696e:		//Tmin
					index = 6;
 6ac:	d6 e0       	ldi	r29, 0x06	; 6
					break;
 6ae:	29 c0       	rjmp	.+82     	; 0x702 <_Z12configPortalv+0x12a>
				inputBuffer[i] = tolower(inputBuffer[i]);

			uint32_t receivedCode = ((uint32_t)inputBuffer[0] << 24) | ((uint32_t)inputBuffer[1] << 16) | ((uint32_t)inputBuffer[2] << 8)| ((uint32_t)inputBuffer[3] << 0);

			int8_t index = -1;
			switch (receivedCode)
 6b0:	88 37       	cpi	r24, 0x78	; 120
 6b2:	21 e6       	ldi	r18, 0x61	; 97
 6b4:	92 07       	cpc	r25, r18
 6b6:	2d e6       	ldi	r18, 0x6D	; 109
 6b8:	a2 07       	cpc	r26, r18
 6ba:	26 e7       	ldi	r18, 0x76	; 118
 6bc:	b2 07       	cpc	r27, r18
 6be:	01 f1       	breq	.+64     	; 0x700 <_Z12configPortalv+0x128>
 6c0:	85 36       	cpi	r24, 0x65	; 101
 6c2:	92 47       	sbci	r25, 0x72	; 114
 6c4:	a0 47       	sbci	r26, 0x70	; 112
 6c6:	b6 47       	sbci	r27, 0x76	; 118
 6c8:	b9 f4       	brne	.+46     	; 0x6f8 <_Z12configPortalv+0x120>
					break;
				case 0x766d6178:		//Vmax
					index = 0;
					break;
				case 0x76707265:		//Vpre
					index = 1;
 6ca:	d1 e0       	ldi	r29, 0x01	; 1
 6cc:	1a c0       	rjmp	.+52     	; 0x702 <_Z12configPortalv+0x12a>
			{
				case 0x64617461:		//command 'data'
					printData();
					break;
				case 0x65786974:		//command 'exit'
					saveEEPROM();
 6ce:	47 df       	rcall	.-370    	; 0x55e <_Z10saveEEPROMv>
					uart_sendString_P(PSTR("data saved, restarting\n"));
 6d0:	8d e8       	ldi	r24, 0x8D	; 141
 6d2:	91 e0       	ldi	r25, 0x01	; 1
 6d4:	db d2       	rcall	.+1462   	; 0xc8c <_Z17uart_sendString_PPKc>
				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
						_BV(WDE) | (value & 0x07)) )
				: "r0"
		);
 6d6:	98 e0       	ldi	r25, 0x08	; 8
 6d8:	88 e1       	ldi	r24, 0x18	; 24
 6da:	0f b6       	in	r0, 0x3f	; 63
 6dc:	f8 94       	cli
 6de:	a8 95       	wdr
 6e0:	81 bd       	out	0x21, r24	; 33
 6e2:	0f be       	out	0x3f, r0	; 63
 6e4:	91 bd       	out	0x21, r25	; 33
 6e6:	ff cf       	rjmp	.-2      	; 0x6e6 <_Z12configPortalv+0x10e>
					break;
				case 0x696d6178:		//Imax
					index = 2;
					break;
				case 0x69637574:		//Icut
					index = 3;
 6e8:	d3 e0       	ldi	r29, 0x03	; 3
					break;
 6ea:	0b c0       	rjmp	.+22     	; 0x702 <_Z12configPortalv+0x12a>
				case 0x69707265:		//Ipre
					index = 4;
 6ec:	d4 e0       	ldi	r29, 0x04	; 4
					break;
 6ee:	09 c0       	rjmp	.+18     	; 0x702 <_Z12configPortalv+0x12a>
				case 0x76636f6e:		//Vcon
					index = 5;
 6f0:	d5 e0       	ldi	r29, 0x05	; 5
					break;
 6f2:	07 c0       	rjmp	.+14     	; 0x702 <_Z12configPortalv+0x12a>
				case 0x746d696e:		//Tmin
					index = 6;
					break;
				case 0x746d6178:		//Tmax
					index = 7;
 6f4:	d7 e0       	ldi	r29, 0x07	; 7
					break;
 6f6:	05 c0       	rjmp	.+10     	; 0x702 <_Z12configPortalv+0x12a>
				default:
					uart_sendString_P(PSTR("Invalid command!\n"));
 6f8:	8b e7       	ldi	r24, 0x7B	; 123
 6fa:	91 e0       	ldi	r25, 0x01	; 1
 6fc:	c7 d2       	rcall	.+1422   	; 0xc8c <_Z17uart_sendString_PPKc>
 6fe:	3f c0       	rjmp	.+126    	; 0x77e <_Z12configPortalv+0x1a6>
					uart_sendString_P(PSTR("data saved, restarting\n"));
					wdt_enable(WDTO_15MS);
					while (1);
					break;
				case 0x766d6178:		//Vmax
					index = 0;
 700:	d0 e0       	ldi	r29, 0x00	; 0
					uart_sendString_P(PSTR("Invalid command!\n"));
			}

			if (index >= 0)
			{
				param[index] = convertInt();
 702:	0d 2f       	mov	r16, r29
 704:	0d 2e       	mov	r0, r29
 706:	00 0c       	add	r0, r0
 708:	11 0b       	sbc	r17, r17
 70a:	0f df       	rcall	.-482    	; 0x52a <_Z10convertIntv>
 70c:	f8 01       	movw	r30, r16
 70e:	ee 0f       	add	r30, r30
 710:	ff 1f       	adc	r31, r31
 712:	ef 58       	subi	r30, 0x8F	; 143
 714:	ff 4f       	sbci	r31, 0xFF	; 255
 716:	91 83       	std	Z+1, r25	; 0x01
 718:	80 83       	st	Z, r24
				checkMinMax(&param[index], index);
 71a:	6d 2f       	mov	r22, r29
 71c:	cf 01       	movw	r24, r30
 71e:	3c df       	rcall	.-392    	; 0x598 <_Z11checkMinMaxPjh>
				
				for (uint8_t j = 0; j < 4; j++)
					uart_sendChar(pgm_read_byte(&paramName[index * 4 + j]));
 720:	78 01       	movw	r14, r16
 722:	ee 0c       	add	r14, r14
 724:	ff 1c       	adc	r15, r15
 726:	ee 0c       	add	r14, r14
 728:	ff 1c       	adc	r15, r15
 72a:	c1 2c       	mov	r12, r1
 72c:	d1 2c       	mov	r13, r1
 72e:	f7 01       	movw	r30, r14
 730:	ec 0d       	add	r30, r12
 732:	fd 1d       	adc	r31, r13
 734:	ea 54       	subi	r30, 0x4A	; 74
 736:	fe 4f       	sbci	r31, 0xFE	; 254
 738:	84 91       	lpm	r24, Z
 73a:	71 d2       	rcall	.+1250   	; 0xc1e <_Z13uart_sendCharc>
 73c:	8f ef       	ldi	r24, 0xFF	; 255
 73e:	c8 1a       	sub	r12, r24
 740:	d8 0a       	sbc	r13, r24
			if (index >= 0)
			{
				param[index] = convertInt();
				checkMinMax(&param[index], index);
				
				for (uint8_t j = 0; j < 4; j++)
 742:	24 e0       	ldi	r18, 0x04	; 4
 744:	c2 16       	cp	r12, r18
 746:	d1 04       	cpc	r13, r1
 748:	91 f7       	brne	.-28     	; 0x72e <_Z12configPortalv+0x156>
					uart_sendChar(pgm_read_byte(&paramName[index * 4 + j]));

				uart_sendString_P(PSTR(" set to "));
 74a:	82 e7       	ldi	r24, 0x72	; 114
 74c:	91 e0       	ldi	r25, 0x01	; 1
 74e:	9e d2       	rcall	.+1340   	; 0xc8c <_Z17uart_sendString_PPKc>

				uart_sendNumber(param[index]);
 750:	00 0f       	add	r16, r16
 752:	11 1f       	adc	r17, r17
 754:	f8 01       	movw	r30, r16
 756:	ef 58       	subi	r30, 0x8F	; 143
 758:	ff 4f       	sbci	r31, 0xFF	; 255
 75a:	6a e0       	ldi	r22, 0x0A	; 10
 75c:	80 81       	ld	r24, Z
 75e:	91 81       	ldd	r25, Z+1	; 0x01
 760:	a3 d2       	rcall	.+1350   	; 0xca8 <_Z15uart_sendNumberjh>

				uart_sendChar(' ');
 762:	80 e2       	ldi	r24, 0x20	; 32
 764:	5c d2       	rcall	.+1208   	; 0xc1e <_Z13uart_sendCharc>
				uart_sendChar(pgm_read_byte(&unit[index * 2]));
 766:	f8 01       	movw	r30, r16
 768:	eb 55       	subi	r30, 0x5B	; 91
 76a:	fe 4f       	sbci	r31, 0xFE	; 254
 76c:	84 91       	lpm	r24, Z
 76e:	57 d2       	rcall	.+1198   	; 0xc1e <_Z13uart_sendCharc>
				uart_sendChar(pgm_read_byte(&unit[index * 2 + 1]));
 770:	f8 01       	movw	r30, r16
 772:	ea 55       	subi	r30, 0x5A	; 90
 774:	fe 4f       	sbci	r31, 0xFE	; 254
 776:	84 91       	lpm	r24, Z
 778:	52 d2       	rcall	.+1188   	; 0xc1e <_Z13uart_sendCharc>
				uart_sendChar('\n');
 77a:	8a e0       	ldi	r24, 0x0A	; 10
 77c:	50 d2       	rcall	.+1184   	; 0xc1e <_Z13uart_sendCharc>
			{
				param[index] = convertInt();
				checkMinMax(&param[index], index);
				
				for (uint8_t j = 0; j < 4; j++)
					uart_sendChar(pgm_read_byte(&paramName[index * 4 + j]));
 77e:	80 e0       	ldi	r24, 0x00	; 0
 780:	90 e0       	ldi	r25, 0x00	; 0
				uart_sendChar(pgm_read_byte(&unit[index * 2 + 1]));
				uart_sendChar('\n');
			}
			
			for (uint8_t i = 0; i < 12; i ++)
				inputBuffer[i] = ' ';
 782:	fc 01       	movw	r30, r24
 784:	ed 57       	subi	r30, 0x7D	; 125
 786:	ff 4f       	sbci	r31, 0xFF	; 255
 788:	b0 82       	st	Z, r11
 78a:	01 96       	adiw	r24, 0x01	; 1
				uart_sendChar(pgm_read_byte(&unit[index * 2]));
				uart_sendChar(pgm_read_byte(&unit[index * 2 + 1]));
				uart_sendChar('\n');
			}
			
			for (uint8_t i = 0; i < 12; i ++)
 78c:	8c 30       	cpi	r24, 0x0C	; 12
 78e:	91 05       	cpc	r25, r1
 790:	c1 f7       	brne	.-16     	; 0x782 <_Z12configPortalv+0x1aa>
 792:	25 cf       	rjmp	.-438    	; 0x5de <_Z12configPortalv+0x6>
					break;
				case 0x76707265:		//Vpre
					index = 1;
					break;
				case 0x696d6178:		//Imax
					index = 2;
 794:	d2 e0       	ldi	r29, 0x02	; 2
 796:	b5 cf       	rjmp	.-150    	; 0x702 <_Z12configPortalv+0x12a>

00000798 <_Z21ws2812_sendarray_maskPhjhS_S_>:
#define w_nop4  w_nop2 w_nop2
#define w_nop8  w_nop4 w_nop4
#define w_nop16 w_nop8 w_nop8

void ws2812_sendarray_mask(uint8_t *data, uint16_t datlen, uint8_t maskhi, uint8_t *port, uint8_t *portreg)
{
 798:	d9 01       	movw	r26, r18
  uint8_t curbyte,ctr,masklo;
  uint8_t sreg_prev;
  
  masklo = ~maskhi & *port;
 79a:	3c 91       	ld	r19, X
 79c:	54 2f       	mov	r21, r20
 79e:	50 95       	com	r21
 7a0:	53 23       	and	r21, r19
  maskhi |= *port;
 7a2:	34 2b       	or	r19, r20
  sreg_prev=SREG;
 7a4:	2f b7       	in	r18, 0x3f	; 63
  cli();  
 7a6:	f8 94       	cli
 7a8:	fc 01       	movw	r30, r24
 7aa:	68 0f       	add	r22, r24
 7ac:	79 1f       	adc	r23, r25

  while (datlen--) {
 7ae:	e6 17       	cp	r30, r22
 7b0:	f7 07       	cpc	r31, r23
 7b2:	99 f0       	breq	.+38     	; 0x7da <skipone41+0xa>
    curbyte=*data++;
 7b4:	81 91       	ld	r24, Z+
    "       dec   %0    \n\t"    //  '1' [+4] '0' [+3]
    "       brne  loop%=\n\t"    //  '1' [+5] '0' [+4]
    :	"=&d" (ctr)
//    :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
    :	"r" (curbyte), "x" (port), "r" (maskhi), "r" (masklo)
    );
 7b6:	98 e0       	ldi	r25, 0x08	; 8

000007b8 <loop41>:
 7b8:	3c 93       	st	X, r19
 7ba:	00 c0       	rjmp	.+0      	; 0x7bc <loop41+0x4>
 7bc:	00 c0       	rjmp	.+0      	; 0x7be <loop41+0x6>
 7be:	87 ff       	sbrs	r24, 7
 7c0:	5c 93       	st	X, r21
 7c2:	88 0f       	add	r24, r24
 7c4:	00 c0       	rjmp	.+0      	; 0x7c6 <loop41+0xe>
 7c6:	00 c0       	rjmp	.+0      	; 0x7c8 <loop41+0x10>
 7c8:	00 c0       	rjmp	.+0      	; 0x7ca <loop41+0x12>
 7ca:	00 c0       	rjmp	.+0      	; 0x7cc <loop41+0x14>
 7cc:	08 f4       	brcc	.+2      	; 0x7d0 <skipone41>
 7ce:	5c 93       	st	X, r21

000007d0 <skipone41>:
 7d0:	00 00       	nop
 7d2:	00 c0       	rjmp	.+0      	; 0x7d4 <skipone41+0x4>
 7d4:	9a 95       	dec	r25
 7d6:	81 f7       	brne	.-32     	; 0x7b8 <loop41>
  masklo = ~maskhi & *port;
  maskhi |= *port;
  sreg_prev=SREG;
  cli();  

  while (datlen--) {
 7d8:	ea cf       	rjmp	.-44     	; 0x7ae <_Z21ws2812_sendarray_maskPhjhS_S_+0x16>
//    :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
    :	"r" (curbyte), "x" (port), "r" (maskhi), "r" (masklo)
    );
  }
  
  SREG=sreg_prev;
 7da:	2f bf       	out	0x3f, r18	; 63
 7dc:	08 95       	ret

000007de <main>:
void wdt_init(void) __attribute__((naked)) __attribute__((section(".init3")));

int main(void)
{
    //init UART
	uart_init();
 7de:	0c d2       	rcall	.+1048   	; 0xbf8 <_Z9uart_initv>
	uart_sendString_P(PSTR("\n\n\nSTART\n"));
 7e0:	80 e5       	ldi	r24, 0x50	; 80
 7e2:	93 e0       	ldi	r25, 0x03	; 3
 7e4:	53 d2       	rcall	.+1190   	; 0xc8c <_Z17uart_sendString_PPKc>

	//init TIM1 - timekeeping
	TCCR1B = (1 << WGM12) | (1 << CS10) | (1 << CS11);
 7e6:	8b e0       	ldi	r24, 0x0B	; 11
 7e8:	8e bd       	out	0x2e, r24	; 46
	OCR1A = 31250;
 7ea:	82 e1       	ldi	r24, 0x12	; 18
 7ec:	9a e7       	ldi	r25, 0x7A	; 122
 7ee:	9b bd       	out	0x2b, r25	; 43
 7f0:	8a bd       	out	0x2a, r24	; 42
	TIMSK1 = (1 << OCIE1A);
 7f2:	82 e0       	ldi	r24, 0x02	; 2
 7f4:	8c b9       	out	0x0c, r24	; 12

	sei();
 7f6:	78 94       	sei

	//init LED
	DDRA |= (1 << DDA5);
 7f8:	d5 9a       	sbi	0x1a, 5	; 26

	if (readEEPROM())
 7fa:	f1 dd       	rcall	.-1054   	; 0x3de <_Z10readEEPROMv>
 7fc:	88 23       	and	r24, r24
 7fe:	19 f0       	breq	.+6      	; 0x806 <main+0x28>
		uart_sendString_P(PSTR("Data loaded from EEPROM\n"));
 800:	87 e3       	ldi	r24, 0x37	; 55
 802:	93 e0       	ldi	r25, 0x03	; 3
 804:	02 c0       	rjmp	.+4      	; 0x80a <main+0x2c>
	else
		uart_sendString_P(PSTR("Nothing in EEPROM, defaults used\n"));
 806:	85 e1       	ldi	r24, 0x15	; 21
 808:	93 e0       	ldi	r25, 0x03	; 3
 80a:	40 d2       	rcall	.+1152   	; 0xc8c <_Z17uart_sendString_PPKc>

	//check for temperature sensor
	PORTA |= (1 << PA4);
 80c:	dc 9a       	sbi	0x1b, 4	; 27
	if (adc_measurement(ADC_TEMP, 8) < 3200)
 80e:	68 e0       	ldi	r22, 0x08	; 8
 810:	82 e0       	ldi	r24, 0x02	; 2
 812:	bd dd       	rcall	.-1158   	; 0x38e <_Z15adc_measurementhh>
 814:	80 38       	cpi	r24, 0x80	; 128
 816:	9c 40       	sbci	r25, 0x0C	; 12
 818:	30 f4       	brcc	.+12     	; 0x826 <main+0x48>
	{
		temperature_sensor = true;
 81a:	81 e0       	ldi	r24, 0x01	; 1
 81c:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <temperature_sensor>
		uart_sendString_P(PSTR("Temperature sensor detected\n"));
 820:	88 ef       	ldi	r24, 0xF8	; 248
 822:	92 e0       	ldi	r25, 0x02	; 2
 824:	02 c0       	rjmp	.+4      	; 0x82a <main+0x4c>
	}
	else
		uart_sendString_P(PSTR("Temperature sensor not found\n"));
 826:	8a ed       	ldi	r24, 0xDA	; 218
 828:	92 e0       	ldi	r25, 0x02	; 2
 82a:	30 d2       	rcall	.+1120   	; 0xc8c <_Z17uart_sendString_PPKc>
	PORTA &=~(1 << PA4);
 82c:	dc 98       	cbi	0x1b, 4	; 27

	//wait for user to connect the battery
	uart_sendString_P(PSTR("waiting for battery connection...\n"));
 82e:	87 eb       	ldi	r24, 0xB7	; 183
 830:	92 e0       	ldi	r25, 0x02	; 2
 832:	2c d2       	rcall	.+1112   	; 0xc8c <_Z17uart_sendString_PPKc>
			break;

		//we have received something over serial, enter setup portal
		if (dataReady)
		{
			color[2] = 128;
 834:	c0 e8       	ldi	r28, 0x80	; 128
	//wait for user to connect the battery
	uart_sendString_P(PSTR("waiting for battery connection...\n"));
	while (1)
	{
		//we have something connected, skip setup
		if ((adc_measurement(ADC_VOUT, 8) * 2) > param[Vcon])
 836:	68 e0       	ldi	r22, 0x08	; 8
 838:	80 e0       	ldi	r24, 0x00	; 0
 83a:	a9 dd       	rcall	.-1198   	; 0x38e <_Z15adc_measurementhh>
 83c:	88 0f       	add	r24, r24
 83e:	99 1f       	adc	r25, r25
 840:	20 91 7b 00 	lds	r18, 0x007B	; 0x80007b <param+0xa>
 844:	30 91 7c 00 	lds	r19, 0x007C	; 0x80007c <param+0xb>
 848:	28 17       	cp	r18, r24
 84a:	39 07       	cpc	r19, r25
 84c:	e8 f1       	brcs	.+122    	; 0x8c8 <main+0xea>
			break;

		//we have received something over serial, enter setup portal
		if (dataReady)
 84e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <dataReady>
 852:	88 23       	and	r24, r24
 854:	69 f0       	breq	.+26     	; 0x870 <main+0x92>
		{
			color[2] = 128;
 856:	c0 93 68 00 	sts	0x0068, r28	; 0x800068 <color+0x2>
			ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 85a:	0a e3       	ldi	r16, 0x3A	; 58
 85c:	10 e0       	ldi	r17, 0x00	; 0
 85e:	2b e3       	ldi	r18, 0x3B	; 59
 860:	30 e0       	ldi	r19, 0x00	; 0
 862:	40 e2       	ldi	r20, 0x20	; 32
 864:	63 e0       	ldi	r22, 0x03	; 3
 866:	70 e0       	ldi	r23, 0x00	; 0
 868:	86 e6       	ldi	r24, 0x66	; 102
 86a:	90 e0       	ldi	r25, 0x00	; 0
 86c:	95 df       	rcall	.-214    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
			configPortal();
 86e:	b4 de       	rcall	.-664    	; 0x5d8 <_Z12configPortalv>
		}
		
		uart_sendString_P(PSTR("to start config, send anything via serial to the device; alternatively, connect a battery to start charging\n"));
 870:	8a e4       	ldi	r24, 0x4A	; 74
 872:	92 e0       	ldi	r25, 0x02	; 2
 874:	0b d2       	rcall	.+1046   	; 0xc8c <_Z17uart_sendString_PPKc>
		color[2] = 128;
 876:	c0 93 68 00 	sts	0x0068, r28	; 0x800068 <color+0x2>
		ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 87a:	0a e3       	ldi	r16, 0x3A	; 58
 87c:	10 e0       	ldi	r17, 0x00	; 0
 87e:	2b e3       	ldi	r18, 0x3B	; 59
 880:	30 e0       	ldi	r19, 0x00	; 0
 882:	40 e2       	ldi	r20, 0x20	; 32
 884:	63 e0       	ldi	r22, 0x03	; 3
 886:	70 e0       	ldi	r23, 0x00	; 0
 888:	86 e6       	ldi	r24, 0x66	; 102
 88a:	90 e0       	ldi	r25, 0x00	; 0
 88c:	85 df       	rcall	.-246    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 88e:	8f e7       	ldi	r24, 0x7F	; 127
 890:	94 e8       	ldi	r25, 0x84	; 132
 892:	2e e1       	ldi	r18, 0x1E	; 30
 894:	81 50       	subi	r24, 0x01	; 1
 896:	90 40       	sbci	r25, 0x00	; 0
 898:	20 40       	sbci	r18, 0x00	; 0
 89a:	e1 f7       	brne	.-8      	; 0x894 <main+0xb6>
 89c:	00 c0       	rjmp	.+0      	; 0x89e <main+0xc0>
 89e:	00 00       	nop
		_delay_ms(500);
		color[2] = 0;
 8a0:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <color+0x2>
		ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 8a4:	2b e3       	ldi	r18, 0x3B	; 59
 8a6:	30 e0       	ldi	r19, 0x00	; 0
 8a8:	40 e2       	ldi	r20, 0x20	; 32
 8aa:	63 e0       	ldi	r22, 0x03	; 3
 8ac:	70 e0       	ldi	r23, 0x00	; 0
 8ae:	86 e6       	ldi	r24, 0x66	; 102
 8b0:	90 e0       	ldi	r25, 0x00	; 0
 8b2:	72 df       	rcall	.-284    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
 8b4:	8f e7       	ldi	r24, 0x7F	; 127
 8b6:	94 e8       	ldi	r25, 0x84	; 132
 8b8:	2e e1       	ldi	r18, 0x1E	; 30
 8ba:	81 50       	subi	r24, 0x01	; 1
 8bc:	90 40       	sbci	r25, 0x00	; 0
 8be:	20 40       	sbci	r18, 0x00	; 0
 8c0:	e1 f7       	brne	.-8      	; 0x8ba <main+0xdc>
 8c2:	00 c0       	rjmp	.+0      	; 0x8c4 <main+0xe6>
 8c4:	00 00       	nop
 8c6:	b7 cf       	rjmp	.-146    	; 0x836 <main+0x58>
		_delay_ms(500);
	}

	//do we need to precharge?
	if ((adc_measurement(ADC_VOUT, 16) * 2) < param[Vpre])
 8c8:	60 e1       	ldi	r22, 0x10	; 16
 8ca:	80 e0       	ldi	r24, 0x00	; 0
 8cc:	60 dd       	rcall	.-1344   	; 0x38e <_Z15adc_measurementhh>
 8ce:	88 0f       	add	r24, r24
 8d0:	99 1f       	adc	r25, r25
 8d2:	20 91 73 00 	lds	r18, 0x0073	; 0x800073 <param+0x2>
 8d6:	30 91 74 00 	lds	r19, 0x0074	; 0x800074 <param+0x3>
 8da:	82 17       	cp	r24, r18
 8dc:	93 07       	cpc	r25, r19
 8de:	98 f4       	brcc	.+38     	; 0x906 <main+0x128>
	{
		precharge = true;
 8e0:	81 e0       	ldi	r24, 0x01	; 1
 8e2:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <precharge>
		Itemp = param[Imax];
 8e6:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <param+0x4>
 8ea:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <param+0x5>
 8ee:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <Itemp+0x1>
 8f2:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <Itemp>
		param[Imax] = param[Ipre];
 8f6:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <param+0x8>
 8fa:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <param+0x9>
 8fe:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <param+0x5>
 902:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <param+0x4>
	}

	//init TIM0 - 8 bit PWM @ 80 kHz
	TCCR0A = (1 << WGM00) | (1 << WGM01) | (1 << COM0A1) | (1 << COM0A0);
 906:	83 ec       	ldi	r24, 0xC3	; 195
 908:	80 bf       	out	0x30, r24	; 48
	DDRB |= (1 << DDB2);
 90a:	ba 9a       	sbi	0x17, 2	; 23
	PWM_START;
 90c:	81 e0       	ldi	r24, 0x01	; 1
 90e:	83 bf       	out	0x33, r24	; 51

	update = true;
 910:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <update>
		if (update)
		{
			update = false;

			if (temperature_sensor)
				Tact = (((uint16_t)adc_measurement(ADC_TEMP, 8) - 400) / 20);
 914:	c4 e1       	ldi	r28, 0x14	; 20
 916:	d0 e0       	ldi	r29, 0x00	; 0
					PWM_STOP;
					while (1);
				}
			
				//we are not finished - orange color
				color[0] = 50; color[1] = 128; color[2] = 0;
 918:	52 e3       	ldi	r21, 0x32	; 50
 91a:	d5 2e       	mov	r13, r21
 91c:	60 e8       	ldi	r22, 0x80	; 128
 91e:	f6 2e       	mov	r15, r22
			int16_t Vdelta = param[Vmax] - Vact;
			int16_t Idelta = param[Imax] - Iact;
			if (precharge)
			{
				//precharge - purple color
				color[0] = 35; color[1] = 80; color[2] = 80;
 920:	73 e2       	ldi	r23, 0x23	; 35
 922:	c7 2e       	mov	r12, r23
 924:	e0 e5       	ldi	r30, 0x50	; 80
 926:	ee 2e       	mov	r14, r30
	PWM_START;

	update = true;
    while (1)
    {
		Vact = adc_measurement(ADC_VOUT, 16) * 2;
 928:	60 e1       	ldi	r22, 0x10	; 16
 92a:	80 e0       	ldi	r24, 0x00	; 0
 92c:	30 dd       	rcall	.-1440   	; 0x38e <_Z15adc_measurementhh>
 92e:	88 0f       	add	r24, r24
 930:	99 1f       	adc	r25, r25
 932:	90 93 70 00 	sts	0x0070, r25	; 0x800070 <Vact+0x1>
 936:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <Vact>
		Iact = adc_measurement(ADC_IOUT, 16) / 2;
 93a:	60 e1       	ldi	r22, 0x10	; 16
 93c:	81 e0       	ldi	r24, 0x01	; 1
 93e:	27 dd       	rcall	.-1458   	; 0x38e <_Z15adc_measurementhh>
 940:	9c 01       	movw	r18, r24
 942:	36 95       	lsr	r19
 944:	27 95       	ror	r18
 946:	30 93 6e 00 	sts	0x006E, r19	; 0x80006e <Iact+0x1>
 94a:	20 93 6d 00 	sts	0x006D, r18	; 0x80006d <Iact>

		//CC-CV regulation loop
		if (((Vact > param[Vmax]) | (Iact > param[Imax])) & (OCR0A > 0))
 94e:	e0 91 71 00 	lds	r30, 0x0071	; 0x800071 <param>
 952:	f0 91 72 00 	lds	r31, 0x0072	; 0x800072 <param+0x1>
 956:	60 91 6f 00 	lds	r22, 0x006F	; 0x80006f <Vact>
 95a:	70 91 70 00 	lds	r23, 0x0070	; 0x800070 <Vact+0x1>
 95e:	40 91 75 00 	lds	r20, 0x0075	; 0x800075 <param+0x4>
 962:	50 91 76 00 	lds	r21, 0x0076	; 0x800076 <param+0x5>
 966:	a6 b7       	in	r26, 0x36	; 54
 968:	81 e0       	ldi	r24, 0x01	; 1
 96a:	e6 17       	cp	r30, r22
 96c:	f7 07       	cpc	r31, r23
 96e:	08 f0       	brcs	.+2      	; 0x972 <main+0x194>
 970:	80 e0       	ldi	r24, 0x00	; 0
 972:	91 e0       	ldi	r25, 0x01	; 1
 974:	42 17       	cp	r20, r18
 976:	53 07       	cpc	r21, r19
 978:	08 f0       	brcs	.+2      	; 0x97c <main+0x19e>
 97a:	90 e0       	ldi	r25, 0x00	; 0
 97c:	98 2b       	or	r25, r24
 97e:	29 f0       	breq	.+10     	; 0x98a <main+0x1ac>
 980:	aa 23       	and	r26, r26
 982:	19 f0       	breq	.+6      	; 0x98a <main+0x1ac>
			OCR0A--;
 984:	86 b7       	in	r24, 0x36	; 54
 986:	81 50       	subi	r24, 0x01	; 1
 988:	11 c0       	rjmp	.+34     	; 0x9ac <main+0x1ce>
		else if ((Vact < param[Vmax]) & (Iact < param[Imax]) & (OCR0A < 0xFF))
 98a:	a6 b7       	in	r26, 0x36	; 54
 98c:	81 e0       	ldi	r24, 0x01	; 1
 98e:	6e 17       	cp	r22, r30
 990:	7f 07       	cpc	r23, r31
 992:	08 f0       	brcs	.+2      	; 0x996 <main+0x1b8>
 994:	80 e0       	ldi	r24, 0x00	; 0
 996:	91 e0       	ldi	r25, 0x01	; 1
 998:	af 3f       	cpi	r26, 0xFF	; 255
 99a:	09 f4       	brne	.+2      	; 0x99e <main+0x1c0>
 99c:	90 e0       	ldi	r25, 0x00	; 0
 99e:	98 23       	and	r25, r24
 9a0:	31 f0       	breq	.+12     	; 0x9ae <main+0x1d0>
 9a2:	24 17       	cp	r18, r20
 9a4:	35 07       	cpc	r19, r21
 9a6:	18 f4       	brcc	.+6      	; 0x9ae <main+0x1d0>
			OCR0A++;
 9a8:	86 b7       	in	r24, 0x36	; 54
 9aa:	8f 5f       	subi	r24, 0xFF	; 255
 9ac:	86 bf       	out	0x36, r24	; 54

		if (update)
 9ae:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <update>
 9b2:	88 23       	and	r24, r24
 9b4:	09 f4       	brne	.+2      	; 0x9b8 <main+0x1da>
 9b6:	b8 cf       	rjmp	.-144    	; 0x928 <main+0x14a>
		{
			update = false;
 9b8:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <update>

			if (temperature_sensor)
 9bc:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <temperature_sensor>
 9c0:	88 23       	and	r24, r24
 9c2:	61 f0       	breq	.+24     	; 0x9dc <main+0x1fe>
				Tact = (((uint16_t)adc_measurement(ADC_TEMP, 8) - 400) / 20);
 9c4:	68 e0       	ldi	r22, 0x08	; 8
 9c6:	82 e0       	ldi	r24, 0x02	; 2
 9c8:	e2 dc       	rcall	.-1596   	; 0x38e <_Z15adc_measurementhh>
 9ca:	80 59       	subi	r24, 0x90	; 144
 9cc:	91 40       	sbci	r25, 0x01	; 1
 9ce:	be 01       	movw	r22, r28
 9d0:	00 d2       	rcall	.+1024   	; 0xdd2 <__udivmodhi4>
 9d2:	70 93 6a 00 	sts	0x006A, r23	; 0x80006a <Tact+0x1>
 9d6:	60 93 69 00 	sts	0x0069, r22	; 0x800069 <Tact>
 9da:	04 c0       	rjmp	.+8      	; 0x9e4 <main+0x206>
			else
				Tact = 0;
 9dc:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <Tact+0x1>
 9e0:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <Tact>

			uart_sendString_P(PSTR("Vout: "));
 9e4:	83 e4       	ldi	r24, 0x43	; 67
 9e6:	92 e0       	ldi	r25, 0x02	; 2
 9e8:	51 d1       	rcall	.+674    	; 0xc8c <_Z17uart_sendString_PPKc>
			uart_sendNumber(Vact);
 9ea:	6a e0       	ldi	r22, 0x0A	; 10
 9ec:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <Vact>
 9f0:	90 91 70 00 	lds	r25, 0x0070	; 0x800070 <Vact+0x1>
 9f4:	59 d1       	rcall	.+690    	; 0xca8 <_Z15uart_sendNumberjh>
			uart_sendString_P(PSTR(" mV; Iout: "));
 9f6:	87 e3       	ldi	r24, 0x37	; 55
 9f8:	92 e0       	ldi	r25, 0x02	; 2
 9fa:	48 d1       	rcall	.+656    	; 0xc8c <_Z17uart_sendString_PPKc>
			uart_sendNumber(Iact);
 9fc:	6a e0       	ldi	r22, 0x0A	; 10
 9fe:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <Iact>
 a02:	90 91 6e 00 	lds	r25, 0x006E	; 0x80006e <Iact+0x1>
 a06:	50 d1       	rcall	.+672    	; 0xca8 <_Z15uart_sendNumberjh>
			uart_sendString_P(PSTR(" mA; t: "));
 a08:	8e e2       	ldi	r24, 0x2E	; 46
 a0a:	92 e0       	ldi	r25, 0x02	; 2
 a0c:	3f d1       	rcall	.+638    	; 0xc8c <_Z17uart_sendString_PPKc>
			uart_sendNumber(Tact);
 a0e:	6a e0       	ldi	r22, 0x0A	; 10
 a10:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <Tact>
 a14:	90 91 6a 00 	lds	r25, 0x006A	; 0x80006a <Tact+0x1>
 a18:	47 d1       	rcall	.+654    	; 0xca8 <_Z15uart_sendNumberjh>
			uart_sendString_P(PSTR(" C\n"));
 a1a:	8a e2       	ldi	r24, 0x2A	; 42
 a1c:	92 e0       	ldi	r25, 0x02	; 2
 a1e:	36 d1       	rcall	.+620    	; 0xc8c <_Z17uart_sendString_PPKc>
			uart_sendString_P(PSTR("\n"));
 a20:	88 e2       	ldi	r24, 0x28	; 40
 a22:	92 e0       	ldi	r25, 0x02	; 2
 a24:	33 d1       	rcall	.+614    	; 0xc8c <_Z17uart_sendString_PPKc>

			//precharge-CC-CV-finished determination loop
			int16_t Vdelta = param[Vmax] - Vact;
			int16_t Idelta = param[Imax] - Iact;
			if (precharge)
 a26:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <precharge>
 a2a:	88 23       	and	r24, r24
 a2c:	41 f1       	breq	.+80     	; 0xa7e <main+0x2a0>
			{
				//precharge - purple color
				color[0] = 35; color[1] = 80; color[2] = 80;
 a2e:	c0 92 66 00 	sts	0x0066, r12	; 0x800066 <color>
 a32:	e0 92 67 00 	sts	0x0067, r14	; 0x800067 <color+0x1>
 a36:	e0 92 68 00 	sts	0x0068, r14	; 0x800068 <color+0x2>
				ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 a3a:	0a e3       	ldi	r16, 0x3A	; 58
 a3c:	10 e0       	ldi	r17, 0x00	; 0
 a3e:	2b e3       	ldi	r18, 0x3B	; 59
 a40:	30 e0       	ldi	r19, 0x00	; 0
 a42:	40 e2       	ldi	r20, 0x20	; 32
 a44:	63 e0       	ldi	r22, 0x03	; 3
 a46:	70 e0       	ldi	r23, 0x00	; 0
 a48:	86 e6       	ldi	r24, 0x66	; 102
 a4a:	90 e0       	ldi	r25, 0x00	; 0
 a4c:	a5 de       	rcall	.-694    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>

				//are the conditions for precharging still true?
				if ((adc_measurement(ADC_VOUT, 16) * 2) > param[Vpre])
 a4e:	60 e1       	ldi	r22, 0x10	; 16
 a50:	80 e0       	ldi	r24, 0x00	; 0
 a52:	9d dc       	rcall	.-1734   	; 0x38e <_Z15adc_measurementhh>
 a54:	88 0f       	add	r24, r24
 a56:	99 1f       	adc	r25, r25
 a58:	20 91 73 00 	lds	r18, 0x0073	; 0x800073 <param+0x2>
 a5c:	30 91 74 00 	lds	r19, 0x0074	; 0x800074 <param+0x3>
 a60:	28 17       	cp	r18, r24
 a62:	39 07       	cpc	r19, r25
 a64:	08 f0       	brcs	.+2      	; 0xa68 <main+0x28a>
 a66:	5d c0       	rjmp	.+186    	; 0xb22 <main+0x344>
				{
					precharge = false;
 a68:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <precharge>
					param[Imax] = Itemp;
 a6c:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <Itemp>
 a70:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <Itemp+0x1>
 a74:	90 93 76 00 	sts	0x0076, r25	; 0x800076 <param+0x5>
 a78:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <param+0x4>
 a7c:	52 c0       	rjmp	.+164    	; 0xb22 <main+0x344>
			uart_sendString_P(PSTR(" C\n"));
			uart_sendString_P(PSTR("\n"));

			//precharge-CC-CV-finished determination loop
			int16_t Vdelta = param[Vmax] - Vact;
			int16_t Idelta = param[Imax] - Iact;
 a7e:	40 91 6d 00 	lds	r20, 0x006D	; 0x80006d <Iact>
 a82:	50 91 6e 00 	lds	r21, 0x006E	; 0x80006e <Iact+0x1>
				{
					precharge = false;
					param[Imax] = Itemp;
				}
			}
			else if (abs(Vdelta) >= abs(Idelta))
 a86:	20 91 71 00 	lds	r18, 0x0071	; 0x800071 <param>
 a8a:	30 91 72 00 	lds	r19, 0x0072	; 0x800072 <param+0x1>
 a8e:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <Vact>
 a92:	90 91 70 00 	lds	r25, 0x0070	; 0x800070 <Vact+0x1>
 a96:	28 1b       	sub	r18, r24
 a98:	39 0b       	sbc	r19, r25
 a9a:	37 ff       	sbrs	r19, 7
 a9c:	03 c0       	rjmp	.+6      	; 0xaa4 <main+0x2c6>
 a9e:	31 95       	neg	r19
 aa0:	21 95       	neg	r18
 aa2:	31 09       	sbc	r19, r1
 aa4:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <param+0x4>
 aa8:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <param+0x5>
 aac:	84 1b       	sub	r24, r20
 aae:	95 0b       	sbc	r25, r21
 ab0:	97 ff       	sbrs	r25, 7
 ab2:	03 c0       	rjmp	.+6      	; 0xaba <main+0x2dc>
 ab4:	91 95       	neg	r25
 ab6:	81 95       	neg	r24
 ab8:	91 09       	sbc	r25, r1
 aba:	28 17       	cp	r18, r24
 abc:	39 07       	cpc	r19, r25
 abe:	1c f0       	brlt	.+6      	; 0xac6 <main+0x2e8>
			{
				//CC mode - red color
				color[0] = 0; color[1] = 128; color[2] = 0;
 ac0:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <color>
 ac4:	20 c0       	rjmp	.+64     	; 0xb06 <main+0x328>
				ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
			}
			else
			{
				//CV mode
				if (Iact < param[Icut])
 ac6:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <param+0x6>
 aca:	90 91 78 00 	lds	r25, 0x0078	; 0x800078 <param+0x7>
 ace:	48 17       	cp	r20, r24
 ad0:	59 07       	cpc	r21, r25
 ad2:	b8 f4       	brcc	.+46     	; 0xb02 <main+0x324>
				{
					//we are finished - green color
					color[0] = 128; color[1] = 0; color[2] = 0;
 ad4:	80 e8       	ldi	r24, 0x80	; 128
 ad6:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <color>
 ada:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <color+0x1>
 ade:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <color+0x2>
					ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 ae2:	0a e3       	ldi	r16, 0x3A	; 58
 ae4:	10 e0       	ldi	r17, 0x00	; 0
 ae6:	2b e3       	ldi	r18, 0x3B	; 59
 ae8:	30 e0       	ldi	r19, 0x00	; 0
 aea:	40 e2       	ldi	r20, 0x20	; 32
 aec:	63 e0       	ldi	r22, 0x03	; 3
 aee:	70 e0       	ldi	r23, 0x00	; 0
 af0:	86 e6       	ldi	r24, 0x66	; 102
 af2:	90 e0       	ldi	r25, 0x00	; 0
 af4:	51 de       	rcall	.-862    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
					uart_sendString_P(PSTR("==FINISHED==\n"));
 af6:	8a e1       	ldi	r24, 0x1A	; 26
 af8:	92 e0       	ldi	r25, 0x02	; 2
 afa:	c8 d0       	rcall	.+400    	; 0xc8c <_Z17uart_sendString_PPKc>
					OCR0A = 0x00;
 afc:	16 be       	out	0x36, r1	; 54
					PWM_STOP;
 afe:	13 be       	out	0x33, r1	; 51
 b00:	ff cf       	rjmp	.-2      	; 0xb00 <main+0x322>
					while (1);
				}
			
				//we are not finished - orange color
				color[0] = 50; color[1] = 128; color[2] = 0;
 b02:	d0 92 66 00 	sts	0x0066, r13	; 0x800066 <color>
 b06:	f0 92 67 00 	sts	0x0067, r15	; 0x800067 <color+0x1>
 b0a:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <color+0x2>
				ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 b0e:	0a e3       	ldi	r16, 0x3A	; 58
 b10:	10 e0       	ldi	r17, 0x00	; 0
 b12:	2b e3       	ldi	r18, 0x3B	; 59
 b14:	30 e0       	ldi	r19, 0x00	; 0
 b16:	40 e2       	ldi	r20, 0x20	; 32
 b18:	63 e0       	ldi	r22, 0x03	; 3
 b1a:	70 e0       	ldi	r23, 0x00	; 0
 b1c:	86 e6       	ldi	r24, 0x66	; 102
 b1e:	90 e0       	ldi	r25, 0x00	; 0
 b20:	3b de       	rcall	.-906    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
			}

			//temperature check
			if (((Tact > param[Tmax]) | (Tact < Tmin)) && temperature_sensor)
 b22:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <Tact>
 b26:	90 91 6a 00 	lds	r25, 0x006A	; 0x80006a <Tact+0x1>
 b2a:	20 91 7f 00 	lds	r18, 0x007F	; 0x80007f <param+0xe>
 b2e:	30 91 80 00 	lds	r19, 0x0080	; 0x800080 <param+0xf>
 b32:	28 17       	cp	r18, r24
 b34:	39 07       	cpc	r19, r25
 b36:	18 f0       	brcs	.+6      	; 0xb3e <main+0x360>
 b38:	06 97       	sbiw	r24, 0x06	; 6
 b3a:	08 f0       	brcs	.+2      	; 0xb3e <main+0x360>
 b3c:	f5 ce       	rjmp	.-534    	; 0x928 <main+0x14a>
 b3e:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <temperature_sensor>
 b42:	88 23       	and	r24, r24
 b44:	09 f4       	brne	.+2      	; 0xb48 <main+0x36a>
 b46:	f0 ce       	rjmp	.-544    	; 0x928 <main+0x14a>
			{
				uart_sendString_P(PSTR("TEMPERATURE ERROR\n"));
 b48:	87 e0       	ldi	r24, 0x07	; 7
 b4a:	92 e0       	ldi	r25, 0x02	; 2
 b4c:	9f d0       	rcall	.+318    	; 0xc8c <_Z17uart_sendString_PPKc>
				OCR0A = 0x00;
 b4e:	16 be       	out	0x36, r1	; 54
				PWM_STOP;
 b50:	13 be       	out	0x33, r1	; 51
				color[0] = 0; color[2] = 0;
 b52:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <color>
 b56:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <color+0x2>
				while(1)
				{
					color[1] = 128;
 b5a:	c0 e8       	ldi	r28, 0x80	; 128
 b5c:	c0 93 67 00 	sts	0x0067, r28	; 0x800067 <color+0x1>
					ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 b60:	0a e3       	ldi	r16, 0x3A	; 58
 b62:	10 e0       	ldi	r17, 0x00	; 0
 b64:	2b e3       	ldi	r18, 0x3B	; 59
 b66:	30 e0       	ldi	r19, 0x00	; 0
 b68:	40 e2       	ldi	r20, 0x20	; 32
 b6a:	63 e0       	ldi	r22, 0x03	; 3
 b6c:	70 e0       	ldi	r23, 0x00	; 0
 b6e:	86 e6       	ldi	r24, 0x66	; 102
 b70:	90 e0       	ldi	r25, 0x00	; 0
 b72:	12 de       	rcall	.-988    	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
 b74:	8f e7       	ldi	r24, 0x7F	; 127
 b76:	94 e8       	ldi	r25, 0x84	; 132
 b78:	2e e1       	ldi	r18, 0x1E	; 30
 b7a:	81 50       	subi	r24, 0x01	; 1
 b7c:	90 40       	sbci	r25, 0x00	; 0
 b7e:	20 40       	sbci	r18, 0x00	; 0
 b80:	e1 f7       	brne	.-8      	; 0xb7a <main+0x39c>
 b82:	00 c0       	rjmp	.+0      	; 0xb84 <main+0x3a6>
 b84:	00 00       	nop
					_delay_ms(500);
					color[1] = 0;
 b86:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <color+0x1>
					ws2812_sendarray_mask(color, 3, (1 << PA5), (uint8_t*)&PORTA, (uint8_t*)&DDRA);
 b8a:	2b e3       	ldi	r18, 0x3B	; 59
 b8c:	30 e0       	ldi	r19, 0x00	; 0
 b8e:	40 e2       	ldi	r20, 0x20	; 32
 b90:	63 e0       	ldi	r22, 0x03	; 3
 b92:	70 e0       	ldi	r23, 0x00	; 0
 b94:	86 e6       	ldi	r24, 0x66	; 102
 b96:	90 e0       	ldi	r25, 0x00	; 0
 b98:	ff dd       	rcall	.-1026   	; 0x798 <_Z21ws2812_sendarray_maskPhjhS_S_>
 b9a:	8f e7       	ldi	r24, 0x7F	; 127
 b9c:	94 e8       	ldi	r25, 0x84	; 132
 b9e:	2e e1       	ldi	r18, 0x1E	; 30
 ba0:	81 50       	subi	r24, 0x01	; 1
 ba2:	90 40       	sbci	r25, 0x00	; 0
 ba4:	20 40       	sbci	r18, 0x00	; 0
 ba6:	e1 f7       	brne	.-8      	; 0xba0 <main+0x3c2>
 ba8:	00 c0       	rjmp	.+0      	; 0xbaa <main+0x3cc>
 baa:	00 00       	nop
 bac:	d7 cf       	rjmp	.-82     	; 0xb5c <main+0x37e>

00000bae <__vector_6>:
}

//interrupt each 100 ms
volatile uint8_t OVF_counter;
ISR(TIM1_COMPA_vect)
{
 bae:	1f 92       	push	r1
 bb0:	0f 92       	push	r0
 bb2:	0f b6       	in	r0, 0x3f	; 63
 bb4:	0f 92       	push	r0
 bb6:	11 24       	eor	r1, r1
 bb8:	8f 93       	push	r24
 bba:	9f 93       	push	r25
	OVF_counter++;
 bbc:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 bc0:	8f 5f       	subi	r24, 0xFF	; 255
 bc2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	if (OVF_counter >= 10)
 bc6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 bca:	8a 30       	cpi	r24, 0x0A	; 10
 bcc:	70 f0       	brcs	.+28     	; 0xbea <__vector_6+0x3c>
	{
		OVF_counter = 0;
 bce:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
		seconds++;
 bd2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <seconds>
 bd6:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <seconds+0x1>
 bda:	01 96       	adiw	r24, 0x01	; 1
 bdc:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <seconds+0x1>
 be0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <seconds>
		update = true;
 be4:	81 e0       	ldi	r24, 0x01	; 1
 be6:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <update>
	}
}
 bea:	9f 91       	pop	r25
 bec:	8f 91       	pop	r24
 bee:	0f 90       	pop	r0
 bf0:	0f be       	out	0x3f, r0	; 63
 bf2:	0f 90       	pop	r0
 bf4:	1f 90       	pop	r1
 bf6:	18 95       	reti

00000bf8 <_Z9uart_initv>:
bool dataReady;

void uart_init()
{
	//setup TX pin - PA7
	DDRA |= (1 << DDA7);
 bf8:	d7 9a       	sbi	0x1a, 7	; 26
	STX_HIGH;
 bfa:	df 9a       	sbi	0x1b, 7	; 27

	//setup RX pin - PA6
	DDRA &=~(1 << DDA6);
 bfc:	d6 98       	cbi	0x1a, 6	; 26
	GIMSK |= (1 << PCIE0);
 bfe:	8b b7       	in	r24, 0x3b	; 59
 c00:	80 61       	ori	r24, 0x10	; 16
 c02:	8b bf       	out	0x3b, r24	; 59
	PCMSK0 |= (1 << PCINT6);
 c04:	96 9a       	sbi	0x12, 6	; 18
 c06:	80 e0       	ldi	r24, 0x00	; 0
 c08:	90 e0       	ldi	r25, 0x00	; 0

	//fill input buffer with predefined values
	for (uint8_t i = 0; i < 12; i++)
		inputBuffer[i] = ' ';
 c0a:	20 e2       	ldi	r18, 0x20	; 32
 c0c:	fc 01       	movw	r30, r24
 c0e:	ed 57       	subi	r30, 0x7D	; 125
 c10:	ff 4f       	sbci	r31, 0xFF	; 255
 c12:	20 83       	st	Z, r18
 c14:	01 96       	adiw	r24, 0x01	; 1
	DDRA &=~(1 << DDA6);
	GIMSK |= (1 << PCIE0);
	PCMSK0 |= (1 << PCINT6);

	//fill input buffer with predefined values
	for (uint8_t i = 0; i < 12; i++)
 c16:	8c 30       	cpi	r24, 0x0C	; 12
 c18:	91 05       	cpc	r25, r1
 c1a:	c1 f7       	brne	.-16     	; 0xc0c <_Z9uart_initv+0x14>
		inputBuffer[i] = ' ';
}
 c1c:	08 95       	ret

00000c1e <_Z13uart_sendCharc>:

void uart_sendChar(char ch)
{
	cli();
 c1e:	f8 94       	cli
	STX_LOW;
 c20:	df 98       	cbi	0x1b, 7	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 c22:	e3 e0       	ldi	r30, 0x03	; 3
 c24:	f1 e0       	ldi	r31, 0x01	; 1
 c26:	31 97       	sbiw	r30, 0x01	; 1
 c28:	f1 f7       	brne	.-4      	; 0xc26 <_Z13uart_sendCharc+0x8>
 c2a:	00 c0       	rjmp	.+0      	; 0xc2c <_Z13uart_sendCharc+0xe>
 c2c:	00 00       	nop
	_delay_us(SUART_DELAY);
	STX_HIGH;
 c2e:	df 9a       	sbi	0x1b, 7	; 27
 c30:	20 e0       	ldi	r18, 0x00	; 0
 c32:	30 e0       	ldi	r19, 0x00	; 0

	for (uint8_t i = 0; i < 8; i++)
	{
		if ((ch >> i) & 0x01)
 c34:	90 e0       	ldi	r25, 0x00	; 0
 c36:	ac 01       	movw	r20, r24
 c38:	02 2e       	mov	r0, r18
 c3a:	02 c0       	rjmp	.+4      	; 0xc40 <_Z13uart_sendCharc+0x22>
 c3c:	55 95       	asr	r21
 c3e:	47 95       	ror	r20
 c40:	0a 94       	dec	r0
 c42:	e2 f7       	brpl	.-8      	; 0xc3c <_Z13uart_sendCharc+0x1e>
 c44:	40 ff       	sbrs	r20, 0
 c46:	02 c0       	rjmp	.+4      	; 0xc4c <_Z13uart_sendCharc+0x2e>
			STX_HIGH;
 c48:	df 9a       	sbi	0x1b, 7	; 27
 c4a:	01 c0       	rjmp	.+2      	; 0xc4e <_Z13uart_sendCharc+0x30>
		else
			STX_LOW;
 c4c:	df 98       	cbi	0x1b, 7	; 27
 c4e:	e3 e0       	ldi	r30, 0x03	; 3
 c50:	f1 e0       	ldi	r31, 0x01	; 1
 c52:	31 97       	sbiw	r30, 0x01	; 1
 c54:	f1 f7       	brne	.-4      	; 0xc52 <_Z13uart_sendCharc+0x34>
 c56:	00 c0       	rjmp	.+0      	; 0xc58 <_Z13uart_sendCharc+0x3a>
 c58:	00 00       	nop
 c5a:	2f 5f       	subi	r18, 0xFF	; 255
 c5c:	3f 4f       	sbci	r19, 0xFF	; 255
	cli();
	STX_LOW;
	_delay_us(SUART_DELAY);
	STX_HIGH;

	for (uint8_t i = 0; i < 8; i++)
 c5e:	28 30       	cpi	r18, 0x08	; 8
 c60:	31 05       	cpc	r19, r1
 c62:	49 f7       	brne	.-46     	; 0xc36 <_Z13uart_sendCharc+0x18>
		else
			STX_LOW;
		_delay_us(SUART_DELAY);
	}

	STX_HIGH;
 c64:	df 9a       	sbi	0x1b, 7	; 27
	sei();
 c66:	78 94       	sei
 c68:	83 e0       	ldi	r24, 0x03	; 3
 c6a:	91 e0       	ldi	r25, 0x01	; 1
 c6c:	01 97       	sbiw	r24, 0x01	; 1
 c6e:	f1 f7       	brne	.-4      	; 0xc6c <_Z13uart_sendCharc+0x4e>
 c70:	00 c0       	rjmp	.+0      	; 0xc72 <_Z13uart_sendCharc+0x54>
 c72:	00 00       	nop
 c74:	08 95       	ret

00000c76 <_Z15uart_sendStringPc>:
	_delay_us(SUART_DELAY);
}

void uart_sendString(char* s)
{
 c76:	cf 93       	push	r28
 c78:	df 93       	push	r29
 c7a:	ec 01       	movw	r28, r24
	while(*s)  uart_sendChar(*s++);
 c7c:	89 91       	ld	r24, Y+
 c7e:	88 23       	and	r24, r24
 c80:	11 f0       	breq	.+4      	; 0xc86 <_Z15uart_sendStringPc+0x10>
 c82:	cd df       	rcall	.-102    	; 0xc1e <_Z13uart_sendCharc>
 c84:	fb cf       	rjmp	.-10     	; 0xc7c <_Z15uart_sendStringPc+0x6>
}
 c86:	df 91       	pop	r29
 c88:	cf 91       	pop	r28
 c8a:	08 95       	ret

00000c8c <_Z17uart_sendString_PPKc>:

void uart_sendString_P(const char* s)
{
 c8c:	cf 93       	push	r28
 c8e:	df 93       	push	r29
 c90:	ec 01       	movw	r28, r24
	while (pgm_read_byte(s)) uart_sendChar(pgm_read_byte(s++));
 c92:	fe 01       	movw	r30, r28
 c94:	24 91       	lpm	r18, Z
 c96:	22 23       	and	r18, r18
 c98:	21 f0       	breq	.+8      	; 0xca2 <_Z17uart_sendString_PPKc+0x16>
 c9a:	21 96       	adiw	r28, 0x01	; 1
 c9c:	84 91       	lpm	r24, Z
 c9e:	bf df       	rcall	.-130    	; 0xc1e <_Z13uart_sendCharc>
 ca0:	f8 cf       	rjmp	.-16     	; 0xc92 <_Z17uart_sendString_PPKc+0x6>
}
 ca2:	df 91       	pop	r29
 ca4:	cf 91       	pop	r28
 ca6:	08 95       	ret

00000ca8 <_Z15uart_sendNumberjh>:

uint8_t uart_sendNumber(uint16_t num, uint8_t base)
{
 ca8:	0f 93       	push	r16
 caa:	1f 93       	push	r17
 cac:	cf 93       	push	r28
 cae:	df 93       	push	r29
 cb0:	00 d0       	rcall	.+0      	; 0xcb2 <_Z15uart_sendNumberjh+0xa>
 cb2:	00 d0       	rcall	.+0      	; 0xcb4 <_Z15uart_sendNumberjh+0xc>
 cb4:	00 d0       	rcall	.+0      	; 0xcb6 <_Z15uart_sendNumberjh+0xe>
 cb6:	cd b7       	in	r28, 0x3d	; 61
 cb8:	de b7       	in	r29, 0x3e	; 62
 cba:	8c 01       	movw	r16, r24
extern __inline__ __ATTR_GNU_INLINE__
char *itoa (int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__itoa (int, char *, int);
	return __itoa (__val, __s, __radix);
 cbc:	46 2f       	mov	r20, r22
 cbe:	50 e0       	ldi	r21, 0x00	; 0
 cc0:	be 01       	movw	r22, r28
 cc2:	6f 5f       	subi	r22, 0xFF	; 255
 cc4:	7f 4f       	sbci	r23, 0xFF	; 255
 cc6:	be d0       	rcall	.+380    	; 0xe44 <itoa>
	char buf[6];
	itoa(num, buf, base);
	uart_sendString(buf);
 cc8:	ce 01       	movw	r24, r28
 cca:	01 96       	adiw	r24, 0x01	; 1
 ccc:	d4 df       	rcall	.-88     	; 0xc76 <_Z15uart_sendStringPc>

	return (num < 10 ? 1 : (num	< 100 ? 2 : (num < 1000 ? 3 : (num < 10000 ? 4 : 5))));
 cce:	0a 30       	cpi	r16, 0x0A	; 10
 cd0:	11 05       	cpc	r17, r1
 cd2:	60 f0       	brcs	.+24     	; 0xcec <_Z15uart_sendNumberjh+0x44>
 cd4:	04 36       	cpi	r16, 0x64	; 100
 cd6:	11 05       	cpc	r17, r1
 cd8:	58 f0       	brcs	.+22     	; 0xcf0 <_Z15uart_sendNumberjh+0x48>
 cda:	08 3e       	cpi	r16, 0xE8	; 232
 cdc:	83 e0       	ldi	r24, 0x03	; 3
 cde:	18 07       	cpc	r17, r24
 ce0:	48 f0       	brcs	.+18     	; 0xcf4 <_Z15uart_sendNumberjh+0x4c>
 ce2:	00 31       	cpi	r16, 0x10	; 16
 ce4:	17 42       	sbci	r17, 0x27	; 39
 ce6:	40 f0       	brcs	.+16     	; 0xcf8 <_Z15uart_sendNumberjh+0x50>
 ce8:	85 e0       	ldi	r24, 0x05	; 5
 cea:	07 c0       	rjmp	.+14     	; 0xcfa <_Z15uart_sendNumberjh+0x52>
 cec:	81 e0       	ldi	r24, 0x01	; 1
 cee:	05 c0       	rjmp	.+10     	; 0xcfa <_Z15uart_sendNumberjh+0x52>
 cf0:	82 e0       	ldi	r24, 0x02	; 2
 cf2:	03 c0       	rjmp	.+6      	; 0xcfa <_Z15uart_sendNumberjh+0x52>
 cf4:	83 e0       	ldi	r24, 0x03	; 3
 cf6:	01 c0       	rjmp	.+2      	; 0xcfa <_Z15uart_sendNumberjh+0x52>
 cf8:	84 e0       	ldi	r24, 0x04	; 4
}
 cfa:	26 96       	adiw	r28, 0x06	; 6
 cfc:	0f b6       	in	r0, 0x3f	; 63
 cfe:	f8 94       	cli
 d00:	de bf       	out	0x3e, r29	; 62
 d02:	0f be       	out	0x3f, r0	; 63
 d04:	cd bf       	out	0x3d, r28	; 61
 d06:	df 91       	pop	r29
 d08:	cf 91       	pop	r28
 d0a:	1f 91       	pop	r17
 d0c:	0f 91       	pop	r16
 d0e:	08 95       	ret

00000d10 <_Z19uart_sendCharRepeatch>:

void uart_sendCharRepeat(char ch, uint8_t repeats)
{
 d10:	1f 93       	push	r17
 d12:	cf 93       	push	r28
 d14:	df 93       	push	r29
 d16:	d8 2f       	mov	r29, r24
 d18:	16 2f       	mov	r17, r22
	for (uint8_t i = 0; i < repeats; i ++)
 d1a:	c0 e0       	ldi	r28, 0x00	; 0
 d1c:	c1 17       	cp	r28, r17
 d1e:	21 f0       	breq	.+8      	; 0xd28 <_Z19uart_sendCharRepeatch+0x18>
		uart_sendChar(ch);
 d20:	8d 2f       	mov	r24, r29
 d22:	7d df       	rcall	.-262    	; 0xc1e <_Z13uart_sendCharc>
	return (num < 10 ? 1 : (num	< 100 ? 2 : (num < 1000 ? 3 : (num < 10000 ? 4 : 5))));
}

void uart_sendCharRepeat(char ch, uint8_t repeats)
{
	for (uint8_t i = 0; i < repeats; i ++)
 d24:	cf 5f       	subi	r28, 0xFF	; 255
 d26:	fa cf       	rjmp	.-12     	; 0xd1c <_Z19uart_sendCharRepeatch+0xc>
		uart_sendChar(ch);
}
 d28:	df 91       	pop	r29
 d2a:	cf 91       	pop	r28
 d2c:	1f 91       	pop	r17
 d2e:	08 95       	ret

00000d30 <__vector_2>:

//note: putting delays in interrupts is far from ideal. However, since we are out of timers, we don't really have a choice here...
ISR(PCINT0_vect)
{
 d30:	1f 92       	push	r1
 d32:	0f 92       	push	r0
 d34:	0f b6       	in	r0, 0x3f	; 63
 d36:	0f 92       	push	r0
 d38:	11 24       	eor	r1, r1
 d3a:	2f 93       	push	r18
 d3c:	3f 93       	push	r19
 d3e:	4f 93       	push	r20
 d40:	5f 93       	push	r21
 d42:	6f 93       	push	r22
 d44:	7f 93       	push	r23
 d46:	8f 93       	push	r24
 d48:	9f 93       	push	r25
 d4a:	ef 93       	push	r30
 d4c:	ff 93       	push	r31
	if (SRX_LOW)
 d4e:	ce 99       	sbic	0x19, 6	; 25
 d50:	31 c0       	rjmp	.+98     	; 0xdb4 <__vector_2+0x84>
 d52:	85 e8       	ldi	r24, 0x85	; 133
 d54:	91 e0       	ldi	r25, 0x01	; 1
 d56:	01 97       	sbiw	r24, 0x01	; 1
 d58:	f1 f7       	brne	.-4      	; 0xd56 <__vector_2+0x26>
 d5a:	00 c0       	rjmp	.+0      	; 0xd5c <__vector_2+0x2c>
 d5c:	00 00       	nop
 d5e:	20 e0       	ldi	r18, 0x00	; 0
 d60:	30 e0       	ldi	r19, 0x00	; 0
	{
		uint8_t data = 0x0;
 d62:	80 e0       	ldi	r24, 0x00	; 0
		_delay_us(SUART_DELAY + (SUART_DELAY / 2));

		for (uint8_t i = 0; i < 8; i ++)
		{
			if (!SRX_LOW)
			data |= (1 << i);
 d64:	41 e0       	ldi	r20, 0x01	; 1
 d66:	50 e0       	ldi	r21, 0x00	; 0

		_delay_us(SUART_DELAY + (SUART_DELAY / 2));

		for (uint8_t i = 0; i < 8; i ++)
		{
			if (!SRX_LOW)
 d68:	ce 9b       	sbis	0x19, 6	; 25
 d6a:	07 c0       	rjmp	.+14     	; 0xd7a <__vector_2+0x4a>
			data |= (1 << i);
 d6c:	ba 01       	movw	r22, r20
 d6e:	02 2e       	mov	r0, r18
 d70:	01 c0       	rjmp	.+2      	; 0xd74 <__vector_2+0x44>
 d72:	66 0f       	add	r22, r22
 d74:	0a 94       	dec	r0
 d76:	ea f7       	brpl	.-6      	; 0xd72 <__vector_2+0x42>
 d78:	86 2b       	or	r24, r22
 d7a:	e3 e0       	ldi	r30, 0x03	; 3
 d7c:	f1 e0       	ldi	r31, 0x01	; 1
 d7e:	31 97       	sbiw	r30, 0x01	; 1
 d80:	f1 f7       	brne	.-4      	; 0xd7e <__vector_2+0x4e>
 d82:	00 c0       	rjmp	.+0      	; 0xd84 <__vector_2+0x54>
 d84:	00 00       	nop
 d86:	2f 5f       	subi	r18, 0xFF	; 255
 d88:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		uint8_t data = 0x0;

		_delay_us(SUART_DELAY + (SUART_DELAY / 2));

		for (uint8_t i = 0; i < 8; i ++)
 d8a:	28 30       	cpi	r18, 0x08	; 8
 d8c:	31 05       	cpc	r19, r1
 d8e:	61 f7       	brne	.-40     	; 0xd68 <__vector_2+0x38>
			if (!SRX_LOW)
			data |= (1 << i);
			_delay_us(SUART_DELAY);
		}

		if (data != '\n')
 d90:	8a 30       	cpi	r24, 0x0A	; 10
 d92:	59 f0       	breq	.+22     	; 0xdaa <__vector_2+0x7a>
			inputBuffer[bufferPos++] = data;
 d94:	e0 91 82 00 	lds	r30, 0x0082	; 0x800082 <bufferPos>
 d98:	91 e0       	ldi	r25, 0x01	; 1
 d9a:	9e 0f       	add	r25, r30
 d9c:	90 93 82 00 	sts	0x0082, r25	; 0x800082 <bufferPos>
 da0:	f0 e0       	ldi	r31, 0x00	; 0
 da2:	ed 57       	subi	r30, 0x7D	; 125
 da4:	ff 4f       	sbci	r31, 0xFF	; 255
 da6:	80 83       	st	Z, r24
 da8:	05 c0       	rjmp	.+10     	; 0xdb4 <__vector_2+0x84>
		else
		{
			dataReady = true;
 daa:	81 e0       	ldi	r24, 0x01	; 1
 dac:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <dataReady>
			bufferPos = 0;
 db0:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <bufferPos>
		}
	}
}
 db4:	ff 91       	pop	r31
 db6:	ef 91       	pop	r30
 db8:	9f 91       	pop	r25
 dba:	8f 91       	pop	r24
 dbc:	7f 91       	pop	r23
 dbe:	6f 91       	pop	r22
 dc0:	5f 91       	pop	r21
 dc2:	4f 91       	pop	r20
 dc4:	3f 91       	pop	r19
 dc6:	2f 91       	pop	r18
 dc8:	0f 90       	pop	r0
 dca:	0f be       	out	0x3f, r0	; 63
 dcc:	0f 90       	pop	r0
 dce:	1f 90       	pop	r1
 dd0:	18 95       	reti

00000dd2 <__udivmodhi4>:
 dd2:	aa 1b       	sub	r26, r26
 dd4:	bb 1b       	sub	r27, r27
 dd6:	51 e1       	ldi	r21, 0x11	; 17
 dd8:	07 c0       	rjmp	.+14     	; 0xde8 <__udivmodhi4_ep>

00000dda <__udivmodhi4_loop>:
 dda:	aa 1f       	adc	r26, r26
 ddc:	bb 1f       	adc	r27, r27
 dde:	a6 17       	cp	r26, r22
 de0:	b7 07       	cpc	r27, r23
 de2:	10 f0       	brcs	.+4      	; 0xde8 <__udivmodhi4_ep>
 de4:	a6 1b       	sub	r26, r22
 de6:	b7 0b       	sbc	r27, r23

00000de8 <__udivmodhi4_ep>:
 de8:	88 1f       	adc	r24, r24
 dea:	99 1f       	adc	r25, r25
 dec:	5a 95       	dec	r21
 dee:	a9 f7       	brne	.-22     	; 0xdda <__udivmodhi4_loop>
 df0:	80 95       	com	r24
 df2:	90 95       	com	r25
 df4:	bc 01       	movw	r22, r24
 df6:	cd 01       	movw	r24, r26
 df8:	08 95       	ret

00000dfa <atoi>:
 dfa:	fc 01       	movw	r30, r24
 dfc:	88 27       	eor	r24, r24
 dfe:	99 27       	eor	r25, r25
 e00:	e8 94       	clt
 e02:	21 91       	ld	r18, Z+
 e04:	20 32       	cpi	r18, 0x20	; 32
 e06:	e9 f3       	breq	.-6      	; 0xe02 <atoi+0x8>
 e08:	29 30       	cpi	r18, 0x09	; 9
 e0a:	10 f0       	brcs	.+4      	; 0xe10 <atoi+0x16>
 e0c:	2e 30       	cpi	r18, 0x0E	; 14
 e0e:	c8 f3       	brcs	.-14     	; 0xe02 <atoi+0x8>
 e10:	2b 32       	cpi	r18, 0x2B	; 43
 e12:	39 f0       	breq	.+14     	; 0xe22 <atoi+0x28>
 e14:	2d 32       	cpi	r18, 0x2D	; 45
 e16:	31 f4       	brne	.+12     	; 0xe24 <atoi+0x2a>
 e18:	68 94       	set
 e1a:	03 c0       	rjmp	.+6      	; 0xe22 <atoi+0x28>
 e1c:	27 d0       	rcall	.+78     	; 0xe6c <__mulhi_const_10>
 e1e:	82 0f       	add	r24, r18
 e20:	91 1d       	adc	r25, r1
 e22:	21 91       	ld	r18, Z+
 e24:	20 53       	subi	r18, 0x30	; 48
 e26:	2a 30       	cpi	r18, 0x0A	; 10
 e28:	c8 f3       	brcs	.-14     	; 0xe1c <atoi+0x22>
 e2a:	1e f4       	brtc	.+6      	; 0xe32 <atoi+0x38>
 e2c:	90 95       	com	r25
 e2e:	81 95       	neg	r24
 e30:	9f 4f       	sbci	r25, 0xFF	; 255
 e32:	08 95       	ret

00000e34 <tolower>:
 e34:	91 11       	cpse	r25, r1
 e36:	08 95       	ret
 e38:	81 54       	subi	r24, 0x41	; 65
 e3a:	8a 51       	subi	r24, 0x1A	; 26
 e3c:	08 f4       	brcc	.+2      	; 0xe40 <tolower+0xc>
 e3e:	80 5e       	subi	r24, 0xE0	; 224
 e40:	85 5a       	subi	r24, 0xA5	; 165
 e42:	08 95       	ret

00000e44 <itoa>:
 e44:	45 32       	cpi	r20, 0x25	; 37
 e46:	51 05       	cpc	r21, r1
 e48:	18 f4       	brcc	.+6      	; 0xe50 <itoa+0xc>
 e4a:	42 30       	cpi	r20, 0x02	; 2
 e4c:	08 f0       	brcs	.+2      	; 0xe50 <itoa+0xc>
 e4e:	04 c0       	rjmp	.+8      	; 0xe58 <__itoa_ncheck>
 e50:	fb 01       	movw	r30, r22
 e52:	10 82       	st	Z, r1
 e54:	cb 01       	movw	r24, r22
 e56:	08 95       	ret

00000e58 <__itoa_ncheck>:
 e58:	bb 27       	eor	r27, r27
 e5a:	4a 30       	cpi	r20, 0x0A	; 10
 e5c:	31 f4       	brne	.+12     	; 0xe6a <__itoa_ncheck+0x12>
 e5e:	99 23       	and	r25, r25
 e60:	22 f4       	brpl	.+8      	; 0xe6a <__itoa_ncheck+0x12>
 e62:	bd e2       	ldi	r27, 0x2D	; 45
 e64:	90 95       	com	r25
 e66:	81 95       	neg	r24
 e68:	9f 4f       	sbci	r25, 0xFF	; 255
 e6a:	0b c0       	rjmp	.+22     	; 0xe82 <__utoa_common>

00000e6c <__mulhi_const_10>:
 e6c:	bc 01       	movw	r22, r24
 e6e:	88 0f       	add	r24, r24
 e70:	99 1f       	adc	r25, r25
 e72:	88 0f       	add	r24, r24
 e74:	99 1f       	adc	r25, r25
 e76:	86 0f       	add	r24, r22
 e78:	97 1f       	adc	r25, r23
 e7a:	88 0f       	add	r24, r24
 e7c:	99 1f       	adc	r25, r25
 e7e:	08 95       	ret

00000e80 <__utoa_ncheck>:
 e80:	bb 27       	eor	r27, r27

00000e82 <__utoa_common>:
 e82:	fb 01       	movw	r30, r22
 e84:	55 27       	eor	r21, r21
 e86:	aa 27       	eor	r26, r26
 e88:	88 0f       	add	r24, r24
 e8a:	99 1f       	adc	r25, r25
 e8c:	aa 1f       	adc	r26, r26
 e8e:	a4 17       	cp	r26, r20
 e90:	10 f0       	brcs	.+4      	; 0xe96 <__utoa_common+0x14>
 e92:	a4 1b       	sub	r26, r20
 e94:	83 95       	inc	r24
 e96:	50 51       	subi	r21, 0x10	; 16
 e98:	b9 f7       	brne	.-18     	; 0xe88 <__utoa_common+0x6>
 e9a:	a0 5d       	subi	r26, 0xD0	; 208
 e9c:	aa 33       	cpi	r26, 0x3A	; 58
 e9e:	08 f0       	brcs	.+2      	; 0xea2 <__utoa_common+0x20>
 ea0:	a9 5d       	subi	r26, 0xD9	; 217
 ea2:	a1 93       	st	Z+, r26
 ea4:	00 97       	sbiw	r24, 0x00	; 0
 ea6:	79 f7       	brne	.-34     	; 0xe86 <__utoa_common+0x4>
 ea8:	b1 11       	cpse	r27, r1
 eaa:	b1 93       	st	Z+, r27
 eac:	11 92       	st	Z+, r1
 eae:	cb 01       	movw	r24, r22
 eb0:	00 c0       	rjmp	.+0      	; 0xeb2 <strrev>

00000eb2 <strrev>:
 eb2:	dc 01       	movw	r26, r24
 eb4:	fc 01       	movw	r30, r24
 eb6:	67 2f       	mov	r22, r23
 eb8:	71 91       	ld	r23, Z+
 eba:	77 23       	and	r23, r23
 ebc:	e1 f7       	brne	.-8      	; 0xeb6 <strrev+0x4>
 ebe:	32 97       	sbiw	r30, 0x02	; 2
 ec0:	04 c0       	rjmp	.+8      	; 0xeca <strrev+0x18>
 ec2:	7c 91       	ld	r23, X
 ec4:	6d 93       	st	X+, r22
 ec6:	70 83       	st	Z, r23
 ec8:	62 91       	ld	r22, -Z
 eca:	ae 17       	cp	r26, r30
 ecc:	bf 07       	cpc	r27, r31
 ece:	c8 f3       	brcs	.-14     	; 0xec2 <strrev+0x10>
 ed0:	08 95       	ret

00000ed2 <eeprom_read_byte>:
 ed2:	e1 99       	sbic	0x1c, 1	; 28
 ed4:	fe cf       	rjmp	.-4      	; 0xed2 <eeprom_read_byte>
 ed6:	1f ba       	out	0x1f, r1	; 31
 ed8:	8e bb       	out	0x1e, r24	; 30
 eda:	e0 9a       	sbi	0x1c, 0	; 28
 edc:	99 27       	eor	r25, r25
 ede:	8d b3       	in	r24, 0x1d	; 29
 ee0:	08 95       	ret

00000ee2 <eeprom_read_word>:
 ee2:	a8 e1       	ldi	r26, 0x18	; 24
 ee4:	b0 e0       	ldi	r27, 0x00	; 0
 ee6:	42 e0       	ldi	r20, 0x02	; 2
 ee8:	13 c0       	rjmp	.+38     	; 0xf10 <eeprom_read_blraw>

00000eea <eeprom_write_byte>:
 eea:	26 2f       	mov	r18, r22

00000eec <eeprom_write_r18>:
 eec:	e1 99       	sbic	0x1c, 1	; 28
 eee:	fe cf       	rjmp	.-4      	; 0xeec <eeprom_write_r18>
 ef0:	1c ba       	out	0x1c, r1	; 28
 ef2:	1f ba       	out	0x1f, r1	; 31
 ef4:	8e bb       	out	0x1e, r24	; 30
 ef6:	2d bb       	out	0x1d, r18	; 29
 ef8:	0f b6       	in	r0, 0x3f	; 63
 efa:	f8 94       	cli
 efc:	e2 9a       	sbi	0x1c, 2	; 28
 efe:	e1 9a       	sbi	0x1c, 1	; 28
 f00:	0f be       	out	0x3f, r0	; 63
 f02:	01 96       	adiw	r24, 0x01	; 1
 f04:	08 95       	ret

00000f06 <eeprom_write_word>:
 f06:	f1 df       	rcall	.-30     	; 0xeea <eeprom_write_byte>
 f08:	27 2f       	mov	r18, r23
 f0a:	f0 cf       	rjmp	.-32     	; 0xeec <eeprom_write_r18>

00000f0c <eeprom_read_block>:
 f0c:	dc 01       	movw	r26, r24
 f0e:	86 2f       	mov	r24, r22

00000f10 <eeprom_read_blraw>:
 f10:	e8 2f       	mov	r30, r24
 f12:	e1 99       	sbic	0x1c, 1	; 28
 f14:	fe cf       	rjmp	.-4      	; 0xf12 <eeprom_read_blraw+0x2>
 f16:	1f ba       	out	0x1f, r1	; 31
 f18:	05 c0       	rjmp	.+10     	; 0xf24 <eeprom_read_blraw+0x14>
 f1a:	ee bb       	out	0x1e, r30	; 30
 f1c:	e0 9a       	sbi	0x1c, 0	; 28
 f1e:	e3 95       	inc	r30
 f20:	0d b2       	in	r0, 0x1d	; 29
 f22:	0d 92       	st	X+, r0
 f24:	41 50       	subi	r20, 0x01	; 1
 f26:	c8 f7       	brcc	.-14     	; 0xf1a <eeprom_read_blraw+0xa>
 f28:	08 95       	ret

00000f2a <_exit>:
 f2a:	f8 94       	cli

00000f2c <__stop_program>:
 f2c:	ff cf       	rjmp	.-2      	; 0xf2c <__stop_program>
